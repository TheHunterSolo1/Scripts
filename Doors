repo = 'https://raw.githubusercontent.com/bocaj111004/Linora/refs/heads/main/'
 Library      = loadstring(game:HttpGet(repo..'Library.lua'))()
 ThemeManager = loadstring(game:HttpGet(repo..'addons/ThemeManager.lua'))()
 SaveManager  = loadstring(game:HttpGet(repo..'addons/SaveManager.lua'))()
 Options = Library.Options
 Toggles = Library.Toggles

 ESPLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/bocaj111004/ESPLibrary/refs/heads/main/main.lua"))() 
ESPLibrary:SetFadeTime(0.5)
 Window = Library:CreateWindow({Title='ProHax V2',Center=true,AutoShow=true})
 Tabs = {
	Player     = Window:AddTab('Main'),
	Anti       = Window:AddTab('Exploits'),
	Auto       = Window:AddTab('Visuals'),
	Floors     = Window:AddTab('Floors'),
	Fun = Window:AddTab('Trolling'),    UISettings = Window:AddTab('UI Settings'),
}
 PlayerBox = Tabs.Player:AddLeftGroupbox('LocalPlayer')
 AntiBox   = Tabs.Anti:AddLeftGroupbox('Anti Features')
 AutoBox   = Tabs.Player:AddRightGroupbox('Automatically')
 ESPBox    = Tabs.Auto:AddLeftGroupbox('ESP')
 ESPSettings    = Tabs.Auto:AddRightGroupbox('Visuals')
 BypassBox = Tabs.Anti:AddRightGroupbox('Bypass')
 FoolsBox = Tabs.Floors:AddLeftGroupbox('Super Hard Mode 2023')
 BackBox = Tabs.Floors:AddLeftGroupbox('Backdoor')
 MinesBox = Tabs.Floors:AddLeftGroupbox('Mines')
 RetroBox = Tabs.Floors:AddRightGroupbox('Retro')
 RoomsBox = Tabs.Floors:AddRightGroupbox('Rooms')
 SettingsBox = Tabs.UISettings:AddLeftGroupbox('Themes & Keybinds')
 MiscBox = Tabs.Player:AddRightGroupbox('Remotes')

 TrollBox = Tabs.Fun:AddLeftGroupbox('Troll')
-- Services & References
Players           = game:GetService("Players")
PathfindingService = game:GetService("PathfindingService")
RunService        = game:GetService('RunService')
ReplicatedStorage = game:GetService('ReplicatedStorage')
Workspace         = game:GetService('Workspace')
StarterGui        = game:GetService('StarterGui')
Lighting          = game:GetService('Lighting')
LocalPlayer       = Players.LocalPlayer
Character         = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
Humanoid          = Character:WaitForChild('Humanoid')
HumanoidRootPart  = Character:WaitForChild('HumanoidRootPart')
CurrentRooms      = Workspace:WaitForChild('CurrentRooms')
GameData          = ReplicatedStorage:WaitForChild("GameData")
LocalPlayer = Players.LocalPlayer
Camera      = Workspace.CurrentCamera
RunService       = game:GetService("RunService")
ReplicatedDS     = game:GetService("ReplicatedStorage").GameData
doorVelTable     = {}
cachedDoorParts  = {}
local heartConn, roomConn
INTERVAL         = 0.07
BreakDoorsFE = TrollBox:AddToggle("BreakDoorusFE", {
	Text = "Breaks Doors(FE)",
	Tooltip = "Bugs the Game Out"
})
function cleanAll()
	if heartConn then heartConn:Disconnect() heartConn = nil end
	if roomConn then roomConn:Disconnect() roomConn = nil end
	for part, data in pairs(doorVelTable) do
		if data.bv and data.bv.Parent then data.bv:Destroy() end
		if part and part.Parent then part.CanCollide = data.origCollide end
	end
	table.clear(doorVelTable)
	table.clear(cachedDoorParts)
end
function cacheDoorParts()
	table.clear(cachedDoorParts)
	local rooms = workspace.CurrentRooms:GetChildren()
	for i = 1, #rooms do
		local room = rooms[i]
		local children = room:GetChildren()
		for j = 1, #children do
			local obj = children[j]
			if obj:IsA("Model") then
				local descendants = obj:GetDescendants()
				for d = 1, #descendants do
					local descendant = descendants[d]
					if descendant:IsA("BasePart") then
						table.insert(cachedDoorParts, descendant)
					end
				end
			end
		end
	end
end
BreakDoorsFE:OnChanged(function(enabled)
	cleanAll()
	if not enabled then return end
	if tonumber(ReplicatedDS.LatestRoom.Value) >= 98 then BreakDoorsFE:SetValue(false) return end
	cacheDoorParts()
	roomConn = workspace.CurrentRooms.ChildAdded:Connect(function()
		cacheDoorParts()
	end)
	 accumulator = 0
	heartConn = RunService.Heartbeat:Connect(function(dt)
		accumulator = accumulator + dt
		if accumulator < INTERVAL then return end
		accumulator = 0

		if tonumber(ReplicatedDS.LatestRoom.Value) >= 98 then
			BreakDoorsFE:SetValue(false)
			return
		end

		for i = 1, #cachedDoorParts do
			 part = cachedDoorParts[i]
			if isnetworkowner(part) then
				if not doorVelTable[part] then
					local bv = Instance.new("BodyPosition")
					doorVelTable[part] = { origCollide = part.CanCollide, bv = bv }
					part.CanCollide = false
					bv.Name = "TeleportDoorsOnYou"
					bv.MaxForce = Vector3.new(1e9, 1e9,1e9)
					bv.Position = HumanoidRootPart.Position
					bv.Parent = part
				end
			elseif doorVelTable[part] then
				local data = doorVelTable[part]
				if data.bv and data.bv.Parent then data.bv:Destroy() end
				part.CanCollide = data.origCollide
				doorVelTable[part] = nil
			end
		end
	end)
end)

TrollBox:AddToggle('Stunned',{
	Text = "Stunned",
	Tooltip = "Makes People Think your Died",
	Default = false,
	Callback = function(Value)
		LocalPlayer.Character:SetAttribute("Stunned",Value)
	end
})


 lastSpeed = 15
 humanoid = Humanoid
 currentSpeed = lastSpeed

-- Slider
 SpeedSlider = PlayerBox:AddSlider('WalkSpeed', {
	Text = 'WalkSpeed',
	Min = 15, Max = 21, Default = 15,
	Rounding = 0,
	Callback = function(v)
		lastSpeed = v
		
	end
})
local con
 oldspeed = humanoid.WalkSpeed
PlayerBox:AddToggle('Enable WalkSpeed',{
	Text = "Enable WalkSpeed",
	Default = false,
	Callback = function(Value)
if Value then
con = RunService.RenderStepped:Connect(function()
humanoid.WalkSpeed = lastSpeed
end)
else
if con then
con:Disconnect()
con = nil
humanoid.WalkSpeed = oldspeed
end
end
end
})

MiscBox:AddButton({
	Text    = "Revive",
	DoubleClick = true,
	Func = function()
		if game.ReplicatedStorage:FindFirstChild("EntityInfo") then
			game.ReplicatedStorage.EntityInfo.Revive:FireServer()
		else

			game.ReplicatedStorage.RemotesFolder.Revive:FireServer()
		end
	end
})
 Players = game:GetService("Players")
 RS      = game:GetService("ReplicatedStorage")

 player      = Players.LocalPlayer
local playAgain   -- cached RemoteEvent
local charConn    -- Connection to CharacterAdded
local deathConn   -- Connection to humanoid.Died

-- Cache the PlayAgain remote
if RS:FindFirstChild("EntityInfo") then
    playAgain = RS.EntityInfo:WaitForChild("PlayAgain")
elseif RS:FindFirstChild("RemotesFolder") then
    playAgain = RS.RemotesFolder:WaitForChild("PlayAgain")
else
    warn("PlayAgain event not found in ReplicatedStorage")
end

-- When a Humanoid dies, fire the cached event
 function onHumanoidDied()
    if playAgain then
        playAgain:FireServer()
    end
end

-- Hook up death listener on each new Humanoid
 function onCharacterAdded(character)
    -- Clean up previous death connection (if any)
    if deathConn then
        deathConn:Disconnect()
        deathConn = nil
    end
    -- Wait for the Humanoid and connect
     humanoid = character:WaitForChild("Humanoid")
    deathConn = humanoid.Died:Connect(onHumanoidDied)  -- 0
end

-- Toggle handler
AutoBox:AddToggle("AutoPlayAgain", {
    Text         = "Auto Play Again",
    Tooltip      = "Automatically enters a new game when you die",
    CurrentValue = false,
    Callback     = function(enabled)
        if enabled then
            -- Connect CharacterAdded once
            if not charConn then
                charConn = player.CharacterAdded:Connect(onCharacterAdded)
            end
            -- If already in-game, hook the current character
            if player.Character then
                onCharacterAdded(player.Character)
            end
        else
            -- Disconnect both listeners to clean up
            if deathConn then
                deathConn:Disconnect()
                deathConn = nil
            end
            if charConn then
                charConn:Disconnect()
                charConn = nil
            end
        end
    end,
})
MiscBox:AddButton({
	Text    = "PlayAgain",
	DoubleClick = true,
	Func = function()
		if game.ReplicatedStorage:FindFirstChild("EntityInfo") then
			game.ReplicatedStorage.EntityInfo.PlayAgain:FireServer()
		else

			game.ReplicatedStorage.RemotesFolder.PlayAgain:FireServer()
		end
	end
})
MiscBox:AddButton({
	Text    = "Lobby",
	DoubleClick = true,
	Func = function()
		if game.ReplicatedStorage:FindFirstChild("EntityInfo") then
			game.ReplicatedStorage.EntityInfo.Lobby:FireServer()
		else
			game.ReplicatedStorage.RemotesFolder.Lobby:FireServer()
		end
	end
})


Players = game:GetService("Players")
LocalPlayer = Players.LocalPlayer

runSpam = false

TrollBox:AddToggle("SpamOthersTools", {
    Text = "Spam Others Tools (FE)",
    Default = false,
    Callback = function(state)
        runSpam = state
        if runSpam then
            task.spawn(function()
                while runSpam do
                    task.wait(0.9)
                    local players = Players:GetPlayers()
                    for i = 1, #players do
                        local plr = players[i]
                        if plr ~= LocalPlayer then
                            local backpack = plr:FindFirstChild("Backpack")
                            if backpack then
                                local backpackItems = backpack:GetChildren()
                                for j = 1, #backpackItems do
                                    local tool = backpackItems[j]
                                    if tool.ClassName == "Tool" then
                                        local remote = tool:FindFirstChild("Remote")
                                        if remote then remote:FireServer() end
                                    end
                                end
                            end
                            local char = plr.Character
                            if char then
                                local charItems = char:GetChildren()
                                for j = 1, #charItems do
                                    local tool = charItems[j]
                                    if tool.ClassName == "Tool" then
                                        local remote = tool:FindFirstChild("Remote")
                                        if remote then remote:FireServer() end
                                    end
                                end
                            end
                        end
                    end
                end
            end)
        end
    end
}):AddKeyPicker('Spam Others Tools Keybind', {


            Default = 'X', -- String as the name of the keybind (MB1, MB2 for mouse buttons)
            SyncToggleState = true,


            -- You can define custom Modes but I have never had a use for it.
            Mode = Library.IsMobile and 'Toggle' or 'Hold', -- Modes: Always, Toggle, Hold

            Text = 'Spam Others Tools (FE)', -- Text to display in the keybind menu
            NoUI = false, -- Set to true if you want to hide from the Keybind menu,

            -- Occurs when the keybind is clicked, Value is `true`/`false`
            Callback = function(Value)



            end,

            -- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
            ChangedCallback = function(New)
            end
        })

PlayerBox:AddToggle('EnableJump',{
	Text='Enable Jump',Default=false,Callback=function(v)
		Character:SetAttribute('CanJump',v)
	end
})


PlayerBox:AddToggle('NoSlowDown',{
	Text='No Acceleration',Default=false,Callback=function(v)
	for _, HumanoidRootPart in pairs(LocalPlayer.Character:GetDescendants()) do
	if HumanoidRootPart:IsA("BasePart") then
		CustomPhysicalProperties = HumanoidRootPart.CustomPhysicalProperties
		if v then
			HumanoidRootPart.CustomPhysicalProperties = PhysicalProperties.new(100, CustomPhysicalProperties,CustomPhysicalProperties)
		else HumanoidRootPart.CustomPhysicalProperties = CustomPhysicalProperties
		end
	end
	end
	end
})

 Players     = game:GetService("Players")
 RunService  = game:GetService("RunService")

 player      = Players.LocalPlayer
local offsetX, offsetY, offsetZ = 0, 0, 0
 heartbeatConnection = nil
 thingy = nil
local requireSupported = require(LocalPlayer.PlayerScripts.PlayerModule)

if not requireSupported then
	Library:Notify("Require() is not supported. ToolOffset will be hidden.", 3)
	return
end

ESPSettings:AddSlider('ToolOffsetX', {
	Text     = 'ToolOffset X',
	Min      = -10,
	Max      = 10,
	Default  = 0,
	Rounding = 2,
	Callback = function(v) offsetX = v end,
})
ESPSettings:AddSlider('ToolOffsetY', {
	Text     = 'ToolOffset Y',
	Min      = -10,
	Max      = 10,
	Default  = 0,
	Rounding = 2,
	Callback = function(v) offsetY = v end,
})
ESPSettings:AddSlider('ToolOffsetZ', {
	Text     = 'ToolOffset Z',
	Min      = -10,
	Max      = 10,
	Default  = 0,
	Rounding = 2,
	Callback = function(v) offsetZ = v end,
})

ESPSettings:AddToggle('ToolOffset', {
	Text = 'ToolOffset',
	Default = false,
	Callback = function(enabled)
		 gui = player:FindFirstChild("PlayerGui")
		if not gui then return end
		 moduleGui = gui:FindFirstChild("MainUI")
		if not moduleGui then return end
		moduleGui = moduleGui:FindFirstChild("Initiator")
		if not moduleGui then return end
		moduleGui = moduleGui:FindFirstChild("Main_Game")
		if not moduleGui then return end

		thingy = thingy or require(moduleGui)

		if enabled then
			if heartbeatConnection then heartbeatConnection:Disconnect() end
			heartbeatConnection = RunService.Heartbeat:Connect(function()
				if thingy then
					thingy.tooloffset = Vector3.new(offsetX, offsetY, offsetZ)
				end
			end)
		else
			if heartbeatConnection then
				heartbeatConnection:Disconnect()
				heartbeatConnection = nil
			end
			if thingy then
				thingy.tooloffset = Vector3.new(0, 0, 0)
			end
		end
	end,
})

Players = game:GetService("Players") RunService = game:GetService("RunService") ReplicatedStorage = game:GetService("ReplicatedStorage") Workspace = game:GetService("Workspace") local LocalPlayer = Players.LocalPlayer local WorkspaceCamera = Workspace.CurrentCamera local screechCon = nil local hearingCon = nil local eyesCon = nil local lookmanCon = nil AntiBox:AddToggle("AntiScreech", { Text    = "Remove Screech", Default = false, Callback = function(enabled) if screechCon then screechCon:Disconnect() screechCon = nil end if enabled then local camKids = WorkspaceCamera:GetChildren() for i = 1, #camKids do if camKids[i].Name == "GlitchedScreech" then camKids[i]:Destroy() end end screechCon = WorkspaceCamera.ChildAdded:Connect(function(child) if child.Name == "GlitchedScreech" then child:Destroy() end end) local mods = LocalPlayer.PlayerGui :WaitForChild("MainUI") :WaitForChild("Initiator") :WaitForChild("Main_Game") :WaitForChild("RemoteListener") :WaitForChild("Modules") local mod = mods:FindFirstChild("Screech") or mods:FindFirstChild("_Screech") if mod then mod.Name = "_Screech" end else local mods = LocalPlayer.PlayerGui :WaitForChild("MainUI") :WaitForChild("Initiator") :WaitForChild("Main_Game") :WaitForChild("RemoteListener") :WaitForChild("Modules") local mod = mods:FindFirstChild("_Screech") or mods:FindFirstChild("Screech") if mod then mod.Name = "Screech" end end end }) AntiBox:AddToggle("AntiDread", { Text    = "Remove Dread", Default = false, Callback = function(enabled) local mods = LocalPlayer.PlayerGui :WaitForChild("MainUI") :WaitForChild("Initiator") :WaitForChild("Main_Game") :WaitForChild("RemoteListener") :WaitForChild("Modules") local mod = mods:FindFirstChild("Dread") or mods:FindFirstChild("_Dread") if mod then mod.Name = enabled and "_Dread" or "Dread" end end }) local THROTTLE = 0.02 AntiBox:AddToggle("AntiFigureHearing", { Text    = "Anti Figure Hearing", Default = false, Callback = function(enabled) if hearingCon then hearingCon:Disconnect() hearingCon = nil end if enabled then local acc = 0 hearingCon = RunService.Heartbeat:Connect(function(dt) acc = acc + dt if acc < THROTTLE then return end acc = 0 local remotes = ReplicatedStorage:FindFirstChild("RemotesFolder") remotes = remotes and remotes:FindFirstChild("Crouch") if remotes then remotes:FireServer(true) end end) else local remotes = ReplicatedStorage:FindFirstChild("RemotesFolder") remotes = remotes and remotes:FindFirstChild("Crouch") if remotes then remotes:FireServer(false) end end end }) RoomsBox:AddToggle("AntiA90", { Text    = "Remove A90", Default = false, Callback = function(enabled) local mods = LocalPlayer.PlayerGui :WaitForChild("MainUI") :WaitForChild("Initiator") :WaitForChild("Main_Game") :WaitForChild("RemoteListener") :WaitForChild("Modules") local mod = mods:FindFirstChild("A90") or mods:FindFirstChild("_A90") if mod then mod.Name = enabled and "_A90" or "A90" end end }) local motor local descs = ReplicatedStorage:GetDescendants() for i = 1, #descs do if descs[i].Name == "MotorReplication" then motor = descs[i] break end end if motor then AntiBox:AddToggle("Anti-Eyes", { Text    = "Anti-Eyes", Default = false, Callback = function(enabled) if eyesCon then eyesCon:Disconnect() eyesCon = nil end if enabled then eyesCon = RunService.Heartbeat:Connect(function() if Workspace:FindFirstChild("Eyes") then motor:FireServer(-760) end end) end end }) BackBox:AddToggle("Anti-Lookman", { Text    = "Anti-Lookman", Default = false, Callback = function(enabled) if lookmanCon then lookmanCon:Disconnect() lookmanCon = nil end if enabled then lookmanCon = RunService.Heartbeat:Connect(function() if Workspace:FindFirstChild("BackdoorLookman") then motor:FireServer(-760) end end) end end }) end



local Players     = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Stores all the per-part listeners so we can clean up
local propConns = {}

-- Hook one BasePart so that whenever its CanCollide flips away from `desired`,
-- we immediately reset it back
local function watchPart(part, desired)
    if not part:IsA("BasePart") or part.Name == "fakecollision" then return end
    -- ensure initial state
    part.CanCollide = desired

    -- listen for any future changes
    local conn = part:GetPropertyChangedSignal("CanCollide"):Connect(function()
        if part.CanCollide ~= desired then
            part.CanCollide = desired
        end
    end)

    propConns[part] = conn
end

-- Stop watching—and restore default collisions if turning off noclip
local function clearWatch(desiredRestore)
    for part, conn in pairs(propConns) do
        conn:Disconnect()
        if desiredRestore and part.Parent then
            part.CanCollide = desiredRestore
        end
    end
    propConns = {}
end

-- Enable or disable noclip purely via property-changed signals
local function setNoclip(character, on)
    -- first, clear any old hooks
    clearWatch(on and false or true)

    -- then hook all existing descendants
    for _, desc in ipairs(character:GetDescendants()) do
        watchPart(desc, not on)
    end

    -- and hook future descendants too
    if on then
        -- when toggling *on*, any new parts should be watched with desired=false
        propConns._addedConn = character.DescendantAdded:Connect(function(desc)
            watchPart(desc, false)
        end)
    else
        -- when toggling *off*, watch new parts only to force them back to true
        propConns._addedConn = character.DescendantAdded:Connect(function(desc)
            watchPart(desc, true)
        end)
    end
end

-- Hook the toggle
PlayerBox:AddToggle("Noclip", {
    Text    = "Noclip",
    Default = false,
    Callback = function(enabled)
        local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        setNoclip(char, enabled)
    end,
}):AddKeyPicker('Noclip KeyBind', {


            Default = 'N', -- String as the name of the keybind (MB1, MB2 for mouse buttons)
            SyncToggleState = true,


            -- You can define custom Modes but I have never had a use for it.
            Mode = 'Toggle', -- Modes: Always, Toggle, Hold

            Text = 'Noclip', -- Text to display in the keybind menu
            NoUI = false, -- Set to true if you want to hide from the Keybind menu,

            -- Occurs when the keybind is clicked, Value is `true`/`false`
            Callback = function(Value)



            end,

            -- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
            ChangedCallback = function(New)
            end
        })

-- If they respawn mid-noclip, reapply

 Workspace      = game:GetService("Workspace")  Replicated     = game:GetService("ReplicatedStorage")  GameData       = Replicated:WaitForChild("GameData")  LatestRoomVal  = GameData:WaitForChild("LatestRoom")

  settings = {
    ["Remove-Snare"]     = { "Snare", "room" },
    ["Remove-Dupe"]      = { "SideroomDupe", "room" },
    ["Remove-SeekArm"]   = { "Seek_Arm", "room" },
    ["Remove-SeekFire"]  = { "ChandelierObstruction", "room" }
}

local listeners = {}

  function getCurrentRoom() local roomName = tostring(LatestRoomVal.Value) return Workspace.CurrentRooms:FindFirstChild(roomName) end

  function disableTransmitters(inst)  inst:Destroy() end 

   function scanAndZap(root, targetName) local desc = root:GetDescendants() for i = 1, #desc do local inst = desc[i] if inst.Name == targetName then disableTransmitters(inst) end end end

  
 function activate(id, targetName, scope)  if listeners[id] then for _, c in ipairs(listeners[id]) do c:Disconnect() end listeners[id] = nil end

-- Determine roots
 roots = {}
if scope == "global" then
    roots[1] = Workspace
else
     room = getCurrentRoom()
    if not room then
        warn(("[AntiToggle] %s ON but room '%s' not found")
             :format(id, LatestRoomVal.Value))
        return
    end
    roots[1] = room
end

-- One-time scan
for _, root in ipairs(roots) do
    scanAndZap(root, targetName)
end

-- Incremental listeners using DescendantAdded for full coverage
listeners[id] = {}
for _, root in ipairs(roots) do
    local conn = root.DescendantAdded:Connect(function(newInst)
        -- Direct match
        if newInst.Name == targetName then
            disableTransmitters(newInst)
        end
        -- Matches deeper descendants
        local d = newInst:GetDescendants()
        for i = 1, #d do
            if d[i].Name == targetName then
                disableTransmitters(d[i])
            end
        end
    end)
    table.insert(listeners[id], conn)
end
end

  function deactivate(id) local conns = listeners[id] if conns then for _, c in ipairs(conns) do c:Disconnect() end listeners[id] = nil end end

 LatestRoomVal:GetPropertyChangedSignal("Value"):Connect(function() for id, spec in pairs(settings) do local _, scope = unpack(spec) if listeners[id] then activate(id, spec[1], scope) end end end)

 for id, spec in pairs(settings) do local targetName, scope = unpack(spec) AntiBox:AddToggle(id, { Text    = id, Default = false, Callback = function(on) if on then activate(id, targetName, scope) else deactivate(id) end end, }) end

-- Services
RepStore = game:GetService("ReplicatedStorage")
PS       = game:GetService("Players")
RunSvc   = game:GetService("RunService")

-- Player and GUI
LocalPlayer = PS.LocalPlayer
PlayerGui   = LocalPlayer:WaitForChild("PlayerGui")

-- Locate PL event/function
function findPL()
    local desc = RepStore:GetDescendants()
    for i = 1, #desc do
        local inst = desc[i]
        if inst.Name == "PL" and (inst:IsA("RemoteEvent") or inst:IsA("RemoteFunction")) then
            return inst, inst:IsA("RemoteFunction")
        end
    end
end

PL, isFunction = findPL()

-- Parse UI paper into code string
function parsePaper(paper, hintsContainer)
    local children = paper.UI:GetChildren()
    local map, order = {}, {}

    for i = 1, #children do
        local c = children[i]
        local idx = tonumber(c.Name)
        if idx then
            local key = c.ImageRectOffset.X .. "_" .. c.ImageRectOffset.Y
            map[key] = { idx, "" }
            order[idx] = key
        end
    end

    if hintsContainer then
        local hints = hintsContainer:GetChildren()
        for i = 1, #hints do
            local ic = hints[i]
            if ic.Name == "Icon" then
                local key = ic.ImageRectOffset.X .. "_" .. ic.ImageRectOffset.Y
                local entry = map[key]
                if entry then
                    local lbl = ic:FindFirstChildWhichIsA("TextLabel")
                    if lbl then entry[2] = lbl.Text end
                end
            end
        end
    end

    local parts = {}
    for i = 1, #order do
        parts[i] = map[ order[i] ][2]
    end
    return table.concat(parts)
end

-- Generic auto-code manager
function manageToggle(toggleName, mode)
    local heartbeatConn
    local throttle = 0
    local seenPapers = {}
    local lastCodes   = {}

    local function stopAll()
        if heartbeatConn then
            heartbeatConn:Disconnect()
            heartbeatConn = nil
        end
        throttle = 0
        table.clear(seenPapers)
        table.clear(lastCodes)
    end

    AutoBox:AddToggle(toggleName, {
        Text    = (mode == "Fire") and "Auto Library Code " or "Notify Library Code",
        Default = false,
        Tooltip = (mode == "Fire")
                  and "Automatically  Solve Padlock"
                  or "Sent Library Code At Notification",
        Callback = function(enabled)
            stopAll()
            if not enabled then return end

            local function onHeartbeat(dt)
                throttle = throttle + dt
                if throttle < 0.3 then return end
                throttle = 0

                local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                local hints = PlayerGui:FindFirstChild("PermUI")
                              and PlayerGui.PermUI:FindFirstChild("Hints")

                -- collect new papers
                local desc = char:GetDescendants()
                for i = 1, #desc do
                    local d = desc[i]
                    if (d.Name == "LibraryHintPaper" or d.Name == "LibraryHintPaperHard")
                       and not seenPapers[d] then
                        seenPapers[d] = true
                    end
                end

                -- process each paper
                for paper in pairs(seenPapers) do
                    if not paper.Parent then
                        seenPapers[paper] = nil
                        lastCodes[paper]   = nil
                    else
                        local code = parsePaper(paper, hints)
                        if code ~= lastCodes[paper] then
                            lastCodes[paper] = code
                            if mode == "Fire" then
                                if isFunction then
                                    PL:InvokeServer(code)
                                else
                                    PL:FireServer(code)  -- 0
                                end
                            else
                                Library:Notify("Code is "..code, 3)
                            end
                        end
                    end
                end
            end

            heartbeatConn = RunSvc.Heartbeat:Connect(onHeartbeat)
        end,
    })
end

-- Initialize toggles
manageToggle("AutoCodeFire",   "Fire")
manageToggle("AutoCodeNotify", "Notify")
 
local noCamShakeConn
local mod

ESPSettings:AddToggle('No CamShake', {
    Text    = "No CamShake",
    Tooltip = "Stops Camera Shake",
    Default = false,
    Callback = function(enabled)
        if enabled then
            -- First-time setup: ensure require() exists and grab the module
            if typeof(require) ~= "function" then
                warn("Require not supported here")
                return
            end
            mod = require(
                Players.LocalPlayer
                       .PlayerGui
                       .MainUI
                       .Initiator
                       .Main_Game
            )

            -- Now hook Heartbeat: each frame just zero csgo
            noCamShakeConn = RunService.Heartbeat:Connect(function()
                mod.csgo = CFrame.new()
            end)
        else
            -- Disconnect and clear module reference
            if noCamShakeConn then
                noCamShakeConn:Disconnect()
                noCamShakeConn = nil
            end
            mod = nil
        end
    end,
})
--––––––––––––––––––––––––––––––––––––––––––––––
-- TOGGLE: Auto Interact (Descendants + Heartbeat)
--––––––––––––––––––––––––––––––––––––––––––––––
-- Services
Players = game:GetService("Players")
RunService = game:GetService("RunService")
Workspace = game:GetService("Workspace")
LocalPlayer = Players.LocalPlayer

staticIgnored = {
    HidePrompt = true,
    ClimbPrompt = true,
    PushPrompt = true,
    InteractPrompt = true,
    PropPrompt = true,
    StarRiftPrompt = true,
    RiftPrompt = true,
}
ignoredParents = {
    Padlock = true,
    Seek_Arm = true,
    KeyObtainFake = true,
}

supportsFire = pcall(function()
    fireproximityprompt(Instance.new("ProximityPrompt", workspace))
end)

function doPrompt(prompt)
    if supportsFire then
        fireproximityprompt(prompt)
    else
        prompt:InputHoldBegin()
        task.wait(prompt.HoldDuration or 0)
        prompt:InputHoldEnd()
    end
end

storedPrompts = {} -- { [ProximityPrompt] = BasePart }
heartbeatConn = nil
descendantConn = nil
throttleAccumulator = 0

MAX_PROMPTS_PER_STEP = 400
CHECK_DISTANCE = 12.5

roomsFolder = Workspace:WaitForChild("CurrentRooms")

function getPartFrom(parent)
    if parent:IsA("BasePart") then return parent end
    if parent:IsA("Model") then
        for _, obj in ipairs(parent:GetDescendants()) do
            if obj:IsA("BasePart") then return obj end
        end
    end
end

AutoBox:AddToggle("AutoInteract", {
    Text = "Auto Interact",
    Default = false,
    Callback = function(enabled)
        if heartbeatConn then heartbeatConn:Disconnect() heartbeatConn = nil end
        if descendantConn then descendantConn:Disconnect() descendantConn = nil end
        table.clear(storedPrompts)
        throttleAccumulator = 0

        if not enabled then return end

        function trackPrompt(prompt)
            if not prompt:IsDescendantOf(roomsFolder) then return end
            if not prompt.Enabled then return end
            if staticIgnored[prompt.Name] then return end
            local parent = prompt.Parent
            if not parent then return end
            if ignoredParents[parent.Name] then return end

            local part = getPartFrom(parent)
            if part then storedPrompts[prompt] = part end
        end

        local rooms = roomsFolder:GetChildren()
        for i = 1, #rooms do
            local room = rooms[i]
            local descendants = room:GetDescendants()
            for j = 1, #descendants do
                local inst = descendants[j]
                if inst:IsA("ProximityPrompt") then
                    trackPrompt(inst)
                end
            end
        end

        descendantConn = roomsFolder.DescendantAdded:Connect(function(inst)
            if inst:IsA("ProximityPrompt") then
                trackPrompt(inst)
            end
        end)

        heartbeatConn = RunService.Heartbeat:Connect(function(dt)
            throttleAccumulator += dt
            if throttleAccumulator < 0.01 then return end
            throttleAccumulator = 0

            local char = LocalPlayer.Character
            if not char then return end
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            local hrpPos = hrp.Position
            local checked = 0

            for prompt, part in pairs(storedPrompts) do
                if checked >= MAX_PROMPTS_PER_STEP then break end
                if not prompt:IsDescendantOf(roomsFolder) then
                    storedPrompts[prompt] = nil
                    continue
                end
                if not prompt.Enabled or not part or not part:IsDescendantOf(roomsFolder) then
                    storedPrompts[prompt] = nil
                    continue
                end
                if (hrpPos - part.Position).Magnitude <= CHECK_DISTANCE then
                    doPrompt(prompt)
                    checked += 1
                end
            end
        end)
    end
}):AddKeyPicker('Auto Interact Keybind', {


            Default = 'M', -- String as the name of the keybind (MB1, MB2 for mouse buttons)
            SyncToggleState = true,


            -- You can define custom Modes but I have never had a use for it.
            Mode = 'Toggle', -- Modes: Always, Toggle, Hold

            Text = 'Auto Interact', -- Text to display in the keybind menu
            NoUI = false, -- Set to true if you want to hide from the Keybind menu,

            -- Occurs when the keybind is clicked, Value is `true`/`false`
            Callback = function(Value)



            end,

            -- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
            ChangedCallback = function(New)
            end
        })
 RunService   = game:GetService("RunService")
 CurrentRooms = workspace.CurrentRooms
 GameData     = game.ReplicatedStorage.GameData
local Lighting     = game:GetService("Lighting")

-- chunked scan: carve the work into 50-item chunks and yield each frame
 function bindPromptModifier(room, modifierFunc)
    task.spawn(function()
         desc    = room:GetDescendants()
         total   = #desc
         chunkSz = 50
        for i = 1, total, chunkSz do
            for j = i, math.min(i + chunkSz - 1, total) do
                local p = desc[j]
                if p:IsA("ProximityPrompt") then
                    modifierFunc(p)
                end
            end
            RunService.Heartbeat:Wait()
        end
    end)
    return room.DescendantAdded:Connect(function(child)
        if child:IsA("ProximityPrompt") then
            modifierFunc(child)
        end
    end)
end

-- store all connections here
local Conns = {}

-- helper to unbind safely
local function safeDisconnect(conn)
    if conn then conn:Disconnect() end
end

-- InstantInteract
PlayerBox:AddToggle("InstantInteract", {
    Text = "Instant Interact",
    Default = false,
    Callback = function(on)
        safeDisconnect(Conns.II_Prompts)
        safeDisconnect(Conns.II_Room)

        if on then
            local function apply(p) p.HoldDuration = 0 end
            local function bind(room)
                Conns.II_Prompts = bindPromptModifier(room, apply)
            end
            local room = CurrentRooms:FindFirstChild(tostring(GameData.LatestRoom.Value))
            if room then bind(room) end
            Conns.II_Room = GameData.LatestRoom.Changed:Connect(function(id)
                safeDisconnect(Conns.II_Prompts)
                local newRoom = CurrentRooms:FindFirstChild(tostring(id))
                if newRoom then bind(newRoom) end
            end)
        end
    end
})

-- PromptClip
PlayerBox:AddToggle("PromptClip", {
    Text = "Prompt Clip",
    Default = false,
    Callback = function(on)
        safeDisconnect(Conns.PC_Prompts)
        safeDisconnect(Conns.PC_Room)

        if not on then
            -- restore all existing immediately
            local room = CurrentRooms:FindFirstChild(tostring(GameData.LatestRoom.Value))
            if room then
                for _, p in ipairs(room:GetDescendants()) do
                    if p:IsA("ProximityPrompt") then
                        p.RequiresLineOfSight = true
                    end
                end
            end
            return
        end

        local function apply(p) p.RequiresLineOfSight = false end
        local function bind(room)
            Conns.PC_Prompts = bindPromptModifier(room, apply)
        end
        local room = CurrentRooms:FindFirstChild(tostring(GameData.LatestRoom.Value))
        if room then bind(room) end
        Conns.PC_Room = GameData.LatestRoom.Changed:Connect(function(id)
            safeDisconnect(Conns.PC_Prompts)
            local newRoom = CurrentRooms:FindFirstChild(tostring(id))
            if newRoom then bind(newRoom) end
        end)
    end
})

-- PromptReach


-- FullBright
ESPSettings:AddToggle('FullBright', {
    Text    = 'FullBright',
    Default = false,
    Callback = function(on)
        safeDisconnect(Conns.FB)

        -- always restore defaults first
        Lighting.GlobalShadows        = true
        Lighting.Brightness           = 1
        Lighting.ClockTime            = 24
        Lighting.FogEnd               = 10000
        Lighting.OutdoorAmbient       = Color3.fromRGB(128,128,128)
        Lighting.ExposureCompensation = 0

        if on then
            local function apply()
                Lighting.GlobalShadows        = false
                Lighting.Brightness           = 6
                Lighting.ClockTime            = 14
                Lighting.FogEnd               = 1e6
                Lighting.OutdoorAmbient       = Color3.fromRGB(192,192,192)
                Lighting.ExposureCompensation = 0.25
            end
            apply()
            Conns.FB = Lighting.Changed:Connect(function(prop)
                if prop == "ClockTime"
                or prop == "Brightness"
                or prop == "GlobalShadows"
                or prop == "FogEnd"
                or prop == "OutdoorAmbient"
                or prop == "ExposureCompensation"
                then
                    apply()
                end
            end)
        end
    end
})
-- BYPASS BUTTONS & Toggles


-- Speed Bypass
-- Speed Bypass

 Players = game:GetService("Players")
RunService = game:GetService("RunService")
StarterGui = game:GetService("StarterGui")

LocalPlayer = Players.LocalPlayer
bypassActive = false
bypassDelay = 0.21
lastToggle = 0

fakeCollision = nil
hbConn = nil

local function cleanUp()
    if hbConn then
        hbConn:Disconnect()
        hbConn = nil
    end
    if fakeCollision then
        fakeCollision:Destroy()
        fakeCollision = nil
    end
end

function SetSpeedBypassState(on)
    cleanUp()
    bypassActive = on
    SpeedSlider:SetMax(on and 75 or 21)
if not on then return end
    
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

    local original; local root
    for _ = 1, 60 do
        original = character:FindFirstChild("Collision")
        root = character:FindFirstChild("HumanoidRootPart")
        if original and root then break end
        task.wait()
    end
    if not (original and root) then return end
    fakeCollision = original:Clone()
    fakeCollision.Name = "fakecollision"
    fakeCollision.Size = Vector3.new(9, 9, 9)
    fakeCollision.CanCollide = false
    fakeCollision.Massless = false
    fakeCollision.Parent = character

    lastToggle = tick()

    hbConn = RunService.Heartbeat:Connect(function()
        if not bypassActive or not fakeCollision.Parent then
            return cleanUp()
        end

        local now = tick()
        if now - lastToggle >= bypassDelay then
            fakeCollision.Massless = not fakeCollision.Massless
            lastToggle = now
        end
    end)
end

LocalPlayer.CharacterAdded:Connect(cleanUp)

BypassBox:AddSlider("SpeedBypassDelay", {
    Text = "Speed Bypass Delay",
    Min = 0.21,
    Max = 0.23,
    Default = bypassDelay,
    Rounding = 2,
    Callback = function(v)
        bypassDelay = v
    end,
})

BypassBox:AddToggle("SpeedBypass", {
    Text = "Speed Bypass",
    Default = false,
    Callback = SetSpeedBypassState,
})
local lagBackEnabled = false
local lagBackConn
local wasAnchored = false
local debounce = false

BypassBox:AddToggle("LagBackDetection", {
	Text = "Lag Back Detection",
	Default = false,
	Callback = function(v)
		lagBackEnabled = v

		if lagBackConn then
			lagBackConn:Disconnect()
			lagBackConn = nil
		end

		if v then
			local function setupWatcher()
				local char = LocalPlayer.Character
				if not char then return end

				local hrp = char:FindFirstChild("HumanoidRootPart")
				if not hrp then return end

				lagBackConn = RunService.Heartbeat:Connect(function()
					if not lagBackEnabled or not hrp or debounce then return end

					local currentlyAnchored = hrp.Anchored

					if currentlyAnchored and not wasAnchored then
						wasAnchored = true
						Toggles.SpeedBypass:SetValue(false)
					elseif not currentlyAnchored and wasAnchored then
						wasAnchored = false
						debounce = true
						task.delay(0.33, function()
							if lagBackEnabled and not hrp.Anchored then
							
	Toggles.SpeedBypass:SetValue(true)
							end
							debounce = false
						end)
					end
				end)
			end

			if LocalPlayer.Character then
				setupWatcher()
			end
			LocalPlayer.CharacterAdded:Connect(setupWatcher)
		end
	end,
})
-- Services

-- SERVICES
RepStorage = game:GetService("ReplicatedStorage")
Players = game:GetService("Players")
Workspace = game:GetService("Workspace")

player = Players.LocalPlayer
char = player.Character or player.CharacterAdded:Wait()
collision = nil

function onCharacterAdded(newChar)
    char = newChar
    collision = nil
    char:WaitForChild("HumanoidRootPart", 3)
    collision = char:FindFirstChild("Collision")
end

player.CharacterAdded:Connect(onCharacterAdded)
if char then onCharacterAdded(char) end

IsFools = (RepStorage.GameData.Floor.Value == "Fools")
godmodeOffset = 2.05
originalCollisionPos = {}
inGodmode = false

-- toggleGodmode: skipOffset controls whether we move/resize collision part.
function toggleGodmode(state, notify, skipOffset)
    if not char then return end
    collision = char:FindFirstChild("Collision")
    if not (collision and collision:IsA("BasePart")) then return end

    if state and not inGodmode then
        if not skipOffset then
            if not originalCollisionPos[char] then
                originalCollisionPos[char] = collision.Position
            end
            collision.Position = collision.Position - Vector3.new(0, godmodeOffset, 0)
            
        end
        inGodmode = true
        print("Godmode ON")
        if notify then Library:Notify("Godmode Activated Wont Work On A-120", 3) end
    elseif not state and inGodmode then
        if not skipOffset and originalCollisionPos[char] then
            collision.Position = collision.Position + Vector3.new(0,godmodeOffset,0)
            
            originalCollisionPos[char] = nil
        end
        inGodmode = false
        print("Godmode OFF")
        if notify then Library:Notify("Godmode Deactivated", 3) end
    end
end

-- Remove entity-tracking logic since toggle no longer depends on entities.
-- If you want to keep the tables, they are unused now:
-- activeEntities = {}
-- autoAvoidEnabled = false
-- entityNames = { A60 = true, RushMoving = true, AmbushMoving = true, BackdoorRush = true, GlitchRush = true, GlitchAmbush = true, }
-- distanceThreshold = 190

-- The UI toggle callback for direct Godmode enabling/disabling
Godmode = BypassBox:AddToggle("Godmode", {
    Text = "Godmode",
    Default = false,
    Tooltip = "Makes you invincible to entityes",
    Callback = function(enabled)
        if not char then return end
        if not Toggles.AntiFigureHearing.Value then
            Toggles.AntiFigureHearing:SetValue(true)
        end
        collision = char:FindFirstChild("Collision")
        if not (collision and collision:IsA("BasePart")) then
            Library:Notify("Collision part not found!", 3)
            return
        end
        if enabled then
            -- Enable godmode immediately, applying offset/resize
            toggleGodmode(true, true, false)
        else
            -- Disable godmode immediately, restoring collision
            toggleGodmode(false, true, false)
        end
    end,
}):AddKeyPicker('Avoid Entities Keybind', {


            Default = 'G', -- String as the name of the keybind (MB1, MB2 for mouse buttons)
            SyncToggleState = true,


            -- You can define custom Modes but I have never had a use for it.
            Mode = 'Toggle', -- Modes: Always, Toggle, Hold

            Text = 'Godmode', -- Text to display in the keybind menu
            NoUI = false, -- Set to true if you want to hide from the Keybind menu,

            -- Occurs when the keybind is clicked, Value is `true`/`false`
            Callback = function(Value)



            end,

            -- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
            ChangedCallback = function(New)
            end
        })
-- Ensure connection storage exists

local Players    = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace  = game:GetService("Workspace")

local player    = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Whenever the character respawns, re-assign hrp and update filter:
local hrp = character:WaitForChild("HumanoidRootPart")

-- Constants
local RAY_DIST         = 2.7
local TELEPORTS        = 2      -- exactly six teleports
local COOLDOWN         = 0.2
local THROTTLE_INTERVAL = 0.1     -- seconds between raycasts

-- Name of the “fake collision” part inside character
local FAKE_NAME = "fakecollision"

-- State
local bypassActive = false
local debounce     = false
local rayCon, enforceCon

-- RaycastParams (we’ll exclude the character itself)
local rayParams = RaycastParams.new()
rayParams.FilterType  = Enum.RaycastFilterType.Exclude
rayParams.IgnoreWater = true

local function updateFilter()
    rayParams.FilterDescendantsInstances = { character }
end

-- Call once at start
updateFilter()

-- If the player dies/respawns, re-hook hrp & filter
player.CharacterAdded:Connect(function(newChar)
    character = newChar
    hrp = character:WaitForChild("HumanoidRootPart")
    updateFilter()
end)

-- List of object-names to ignore in front of us
local ignoreNames = {
    ["Door"]               = true,
    ["DoorNormal"]         = true,
    ["Luggage_Cart_Crouch"]= true,
    -- add any other parent-names here
}

-- Teleport batch + schedule cooldown
local function triggerBypass()
    debounce = true

    -- Perform six quick teleport “nudges” along our look vector
    for i = 1, TELEPORTS do
        if not bypassActive then
            break
        end

        local collisionPart = character:FindFirstChild("Collision")
        if collisionPart then
            -- move “Collision” far forward for one frame
            collisionPart:PivotTo(collisionPart.CFrame * CFrame.new(0, 0, 5000))
        end

        -- wait one physics frame
        RunService.Heartbeat:Wait()
    end

    -- Stop enforcing “Massless = false” after 1 second
    task.delay(1, function()
        if enforceCon then
            enforceCon:Disconnect()
            enforceCon = nil
        end
    end)

    -- Cooldown before next trigger
    task.delay(COOLDOWN, function()
        debounce = false
    end)
end

-- Per-frame enforcement: keep “fakecollision” Massless = false
 function onEnforce()
    if not bypassActive then
        if enforceCon then
            enforceCon:Disconnect()
            enforceCon = nil
        end
        return
    end

     fake = character:FindFirstChild(FAKE_NAME)
    if fake then
        fake.Massless = false
    end
end

-- Throttled raycast check
 throttleAccum = 0
local function onRayCheck(dt)
    if debounce then
        return
    end

    throttleAccum = throttleAccum + dt
    if throttleAccum < THROTTLE_INTERVAL then
        return
    end
    throttleAccum = 0

    if not hrp or not hrp.Parent then
        return
    end

    -- Prepare origin & direction
     origin    = hrp.Position
     direction = hrp.CFrame.LookVector * RAY_DIST

     hitResult = Workspace:Raycast(origin, direction, rayParams)
    if hitResult and hitResult.Instance:IsA("BasePart") then
        -- If the hit’s parent model/name is in ignoreNames, skip
        local parentName = hitResult.Instance.Parent and hitResult.Instance.Parent.Name
        if not ignoreNames[parentName] then
            -- Something valid is blocking within RAY_DIST → trigger bypass
            triggerBypass()

            -- Start enforcing Massless=false each frame if not done already
            if not enforceCon then
                enforceCon = RunService.Heartbeat:Connect(onEnforce)
            end
        end
    end
end

-- GUI toggle hookup (replace `BypassBox` with your actual UI container)
BypassBox:AddToggle("NB", {
    Text    = "Noclip Bypass",
    Default = false,
    Callback = function(on)
        bypassActive = on
        debounce     = false
        throttleAccum = 0

        if on then
            updateFilter()

            -- Disconnect prior ray connection if any
            if rayCon then
                rayCon:Disconnect()
                rayCon = nil
            end

            -- Connect heartbeat for throttled raycasts
            rayCon = RunService.Heartbeat:Connect(onRayCheck)
        else
            -- Turn off everything
            if rayCon then
                rayCon:Disconnect()
                rayCon = nil
            end
            if enforceCon then
                enforceCon:Disconnect()
                enforceCon = nil
            end
            debounce = false
        end
    end,
}):AddKeyPicker('NB Keybind', {


            Default = 'B', -- String as the name of the keybind (MB1, MB2 for mouse buttons)
            SyncToggleState = true,


            -- You can define custom Modes but I have never had a use for it.
            Mode = 'Toggle', -- Modes: Always, Toggle, Hold

            Text = 'Noclip Bypass', -- Text to display in the keybind menu
            NoUI = false, -- Set to true if you want to hide from the Keybind menu,

            -- Occurs when the keybind is clicked, Value is `true`/`false`
            Callback = function(Value)



            end,

            -- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
            ChangedCallback = function(New)
            end
        })
-- Services


-- Services
 Workspace = game:GetService("Workspace")

-- Wait for the CurrentRooms folder
 CurrentRooms = Workspace:WaitForChild("CurrentRooms")

-- Connection handle
local antiSeekConn

-- Helper: destroy seek triggers and notify
function clearTriggerCollision(obj)
    if obj.Name == "TriggerSeek" or obj.Name == "TriggerEventCollision" then
        obj:Destroy()
        Library:Notify("Deleted Seek (FE) Successfully", 3)
    end
end

-- Toggle
local DeleteSeekToggle = FoolsBox:AddToggle("DeleteSeekFE", {
    Text    = "Delete Seek (FE) Old Built",
    Default = false,
    Tooltip = "Makes Seek never appear",
})

DeleteSeekToggle:OnChanged(function(enabled)
    -- Disconnect any existing listener
    if antiSeekConn then
        antiSeekConn:Disconnect()
        antiSeekConn = nil
    end

    if not enabled then
        return
    end

    -- 1) Initial sweep: destroy existing triggers in the current room
    local room = CurrentRooms:FindFirstChild(tostring(ReplicatedStorage.GameData.LatestRoom.Value))
             or CurrentRooms:GetChildren()[1]
    if room then
        for _, v in ipairs(room:GetDescendants()) do
            clearTriggerCollision(v)
        end
    end

    -- 2) Live cleanup on new instances in any room
    antiSeekConn = CurrentRooms.DescendantAdded:Connect(function(obj)
        clearTriggerCollision(obj)
    end)
end)




-- TimerLever ESP

local workspace         = game:GetService("Workspace")
local RunService        = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LatestRoomValue   = ReplicatedStorage.GameData.LatestRoom

local roomDescConn
local roomChangeConn
local batchSize = 50     -- batch size for initial scan

local AntiFakeBridgeToggle = RetroBox:AddToggle("AntiFakeBridge", {
    Text    = "Anti Fake Bridge",
    Default = false,
})
AntiFakeBridgeToggle:OnChanged(function(isOn)
    -- cleanup
    if roomDescConn then
        roomDescConn:Disconnect()
        roomDescConn = nil
    end
    if roomChangeConn then
        roomChangeConn:Disconnect()
        roomChangeConn = nil
    end

    if not isOn then return end

    local function attachToRoom(room)
        -- initial batch removal
        local descendants = room:GetDescendants()
        local total = #descendants
        task.spawn(function()
            for i = 1, total, batchSize do
                for j = i, math.min(i + batchSize - 1, total) do
                    local obj = descendants[j]
                    if obj:IsA("BasePart") and obj.Name == "Bridge" and not obj.CanCollide then
                        obj:Destroy()
                    end
                end
                task.wait()
            end
        end)

        -- listen for new parts
        roomDescConn = room.DescendantAdded:Connect(function(obj)
            if obj:IsA("BasePart") and obj.Name == "Bridge" and not obj.CanCollide then
                obj:Destroy()
            end
        end)
    end

    local function onRoomChanged()
        if roomDescConn then
            roomDescConn:Disconnect()
            roomDescConn = nil
        end
        local latestRoom = workspace.CurrentRooms:FindFirstChild(LatestRoomValue.Value)
        if latestRoom then
            attachToRoom(latestRoom)
        end
    end

    -- initial attach + listen for room switches
    onRoomChanged()
    roomChangeConn = LatestRoomValue.Changed:Connect(onRoomChanged)
end)


local Workspace  = game:GetService("Workspace")


local EntityNames = {
	RushMoving=true, AmbushMoving=true, A60=true, A120=true,
	BackdoorRush=true, SallyWindow=true, JeffTheKiller=true,
	GrumbleRig=true, GiggleCeiling=false, Snare=false, FigureRig=false,
	FigureRagdoll=false, BananaPeel=false, SeekMovingNewClone=true,
	SeekMoving=true, GlitchRush=true,
	BackdoorLookman = true,
	Eyes = true,
	GlitchAmbush = true,
	Screech = true,
	GlitchedScreech = true,
}

ESPBox:AddToggle("EntityNotify", {
	Text    = "Entity Notify",
	Default = false,
	Callback = function(on)
		local tracked, conn = {}, nil

		local function notifyEntity(e)
			if EntityNames[e.Name] and not tracked[e] then
				tracked[e] = true
				Library:Notify(("â€” %s spawned"):format(e.Name), 3)
			end
		end

		if on then
			-- initial scan
			for _, e in ipairs(Workspace:GetChildren()) do
				notifyEntity(e)
			end
			-- live additions
			conn = Workspace.ChildAdded:Connect(notifyEntity)
		else
			-- stop notifications & clear history
			if conn then conn:Disconnect() end
			tracked = {}
		end
	end,
})



-- Services
 -- ──────────────── Entity ESP ────────────────
 
 -- Services
RunService    = game:GetService("RunService")
 Workspace     = game:GetService("Workspace")
 Replicated    = game:GetService("ReplicatedStorage")
 TweenService  = game:GetService("TweenService")
 Players       = game:GetService("Players")

-- References
 GameData      = Replicated:WaitForChild("GameData")
 LocalPlayer   = Players.LocalPlayer
 PlayerGui     = LocalPlayer:WaitForChild("PlayerGui")

-- Utility: get the current room Model in Workspace.CurrentRooms
 function currentRoom()
    return Workspace.CurrentRooms:FindFirstChild(tostring(GameData.LatestRoom.Value))
end


-- ──────────────── Entity ESP ────────────────
do
    local EntityNames = {
        RushMoving = true, AmbushMoving = true, A60 = true, A120 = true,
        BackdoorRush = true, SallyWindow = true, JeffTheKiller = true,
        GrumbleRig = true, GiggleCeiling = true, Snare = true, FigureRig = true,
        FigureRagdoll = true, BananaPeel = true, SeekMovingNewClone = true,
        SeekMoving = true, GlitchRush = true, Eyes = true, GlitchAmbush = true,
        BackdoorLookman = true,Screech = true,GlitchedScreech = true,
    }

    local tracked = {}    -- [Model] = true when ESP added
    local connAdd = nil

     function processModel(model)
        if tracked[model] then return end
        if not EntityNames[model.Name] then return end

        -- Ensure it has a Humanoid
        if not model:FindFirstChildOfClass("Humanoid") then
            local hum = Instance.new("Humanoid")
            hum.Parent = model
        end

        -- Ensure it has a PrimaryPart
        if not model.PrimaryPart then
            local part = model:FindFirstChildWhichIsA("BasePart")
            if part then
                model.PrimaryPart = part
            end
        end

        if model.PrimaryPart then
            model.PrimaryPart.Transparency = 0.99
           

            ESPLibrary:AddESP({
                Object = model,
                Text   = model.Name,
                Color  = Color3.fromRGB(255, 0, 0),
            })
            tracked[model] = true
        end
    end

    ESPBox:AddToggle("EntityESP", {
        Text    = "Entity ESP",
        Default = false,
        Callback = function(on)
            if on then
                -- Initial scan of existing Models in Workspace
                for _, desc in ipairs(Workspace:GetDescendants()) do
                    if desc:IsA("Model") then
                        processModel(desc)
                    end
                end

                -- Listen for new Models added under Workspace
                connAdd = Workspace.DescendantAdded:Connect(function(desc)
                    if desc:IsA("Model") then
                        processModel(desc)
                    end
                end)
            else
                -- Cleanup: disconnect and remove all ESP
                if connAdd then
                    connAdd:Disconnect()
                    connAdd = nil
                end
                for model in pairs(tracked) do
                    if model.PrimaryPart then
                        ESPLibrary:RemoveESP(model.PrimaryPart)
                    end
                end
                tracked = {}
            end
        end,
    })
end
-- ───────── Room ESP ─────────
-- ───────── Room ESP ─────────
-- Optimized ESP System
do
    local function makeRoomESP(name, matchFn, label, color)
        local tracked = {}
        local connAdd, connRem, connRoom

        local function addESP(obj, txt, clr)
            if tracked[obj] then return end
            local target = obj:IsA("Model") and (obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart"))
                        or (obj:IsA("BasePart") or obj:IsA("MeshPart") or obj:IsA("Attachment")) and obj
            if not target then return end
            ESPLibrary:AddESP{Object = target, Text = txt, Color = clr}
            tracked[obj] = target
        end

        local function removeESP(obj)
            local t = tracked[obj]
            if t then ESPLibrary:RemoveESP(t) end
            tracked[obj] = nil
        end

        local function scanRoom(room)
            if not room then return end
            local desc = room:GetDescendants()
            for i = 1, #desc do
                local d = desc[i]
                if matchFn(d) then
                    local txt = (type(label)=="function" and label(d)) or label
                    addESP(d, txt, color)
                end
            end
        end

        local function clearListeners()
            if connAdd then connAdd:Disconnect() connAdd = nil end
            if connRem then connRem:Disconnect() connRem = nil end
        end

        local function onRoomChanged()
            clearListeners()
            for o in pairs(tracked) do removeESP(o) end
            local room = currentRoom()
            scanRoom(room)
            if not room then return end
            connAdd = room.DescendantAdded:Connect(function(d)
                if matchFn(d) then
                    local txt = (type(label)=="function" and label(d)) or label
                    addESP(d, txt, color)
                end
            end)
            connRem = room.DescendantRemoving:Connect(function(d)
                if tracked[d] then removeESP(d) end
            end)
        end

        ESPBox:AddToggle(name, {
            Text    = name,
            Default = false,
            Callback = function(on)
                if on then
                    connRoom = GameData.LatestRoom:GetPropertyChangedSignal("Value"):Connect(onRoomChanged)
                    onRoomChanged()
                else
                    clearListeners()
                    if connRoom then connRoom:Disconnect() connRoom = nil end
                    for o in pairs(tracked) do removeESP(o) end
                end
            end,
        })
    end
 
-- Table to remember which door got which index


makeRoomESP("DoorESP",
    -- Filter: only Models named "Door"
    function(o)
        return o:IsA("Model") and o.Name == "Door"
    end,
    -- Label: assign an index the first time we see this door,
    -- then always return "Door <index>"
    "Door",
 
    Color3.fromRGB(0, 255, 0)
)
    makeRoomESP("KeyESP",
    function(o)
        return o.Name == "KeyObtain" 
        end,
    "Key",
    Color3.fromRGB(0, 255, 0)
)
    makeRoomESP("ClosetESP",
        function(o)
            return o.Name == "Wardrobe"
                or o.Name == "Rooms_Locker"
                or o.Name == "Backdoor_Wardrobe"
                or o.Name == "Toolshed"
                or o.Name == "Large_Locker"
        end,
        "Closet",
        Color3.fromRGB(0,255,0)
    )
    makeRoomESP("BookESP",
        function(o) return o:IsA("Model") and o.Name == "LiveHintBook" end,
        "Book",
        Color3.fromRGB(0,0,255)
    )
    makeRoomESP("LeverESP",
        function(o) return o:IsA("Model") and o.Name == "LeverForGate" end,
        "Lever",
        Color3.fromRGB(0,0,255)
    )
    makeRoomESP("BreakerESP",
        function(o) return o.Name == "LiveBreakerPolePickup" end,
        "Breaker",
        Color3.fromRGB(0,255,0)
    )
    makeRoomESP("TimerLeverESP",
        function(o) return o.Name == "TimerLever" end,
        "TimerLever",
        Color3.fromRGB(0,0,255)
    )
    makeRoomESP("GeneratorESP",
        function(o) return o.Name == "MinesGenerator" end,
        "Generator",
        Color3.fromRGB(0,255,0)
    )
    makeRoomESP("FuseESP",
        function(o) return o.Name == "FuseObtain" end,
        "Fuse",
        Color3.fromRGB(0,255,0)
    )
    makeRoomESP("ChestESP",
        function(o) return o.Name == "ChestBox" end,
        "Chest",
        Color3.fromRGB(0,255,0)
    )

    local anchors = {
        {Toggle="MinesAnchorESP",    Target="MinesAnchor",       Label="Anchor"},
        {Toggle="ElectricalKeyESP",  Target="ElectricalKeyObtain",Label="ElectricalKey"},
        {Toggle="WaterPumpESP",      Target="WaterPump",         Label="WaterPump"},
    }
    for i = 1, #anchors do
        local a = anchors[i]
        makeRoomESP(a.Toggle,
            function(o) return o.Name == a.Target end,
            a.Label,
            Color3.fromRGB(0,255,0)
        )
    end
end
-- Services
local Players = game:GetService("Players")

-- State
local espConns = {}   -- Connections to disconnect on toggle off
local espItems = {}   -- [player] = espObject

-- Helpers
local function clearPlayers()
    -- Disconnect all connections
    for _, conn in ipairs(espConns) do
        conn:Disconnect()
    end
    espConns = {}

    -- Remove all ESPs
    for _, esp in pairs(espItems) do
        ESPLibrary:RemoveESP(esp)
    end
    espItems = {}
end

local function addPlayer(plr)
    -- When this player's character spawns, add/update ESP
    local function onCharacterAdded(char)
        -- Clean up any existing ESP for old root
        if espItems[plr] then
            ESPLibrary:RemoveESP(espItems[plr])
            espItems[plr] = nil
        end

        -- Wait for Humanoid and PrimaryPart
        local hum = char:WaitForChild("Humanoid", 5)
        local root = char.PrimaryPart
        if hum and root then
            local text = ("%s [%d/%d]"):format(plr.Name, math.floor(hum.Health), math.floor(hum.MaxHealth))
            local esp = ESPLibrary:AddESP{
                Object = root,
                Text   = text,
                Color  = Color3.fromRGB(0,150,255),
            }
            espItems[plr] = esp

            -- Update text on health change
            table.insert(espConns, hum.HealthChanged:Connect(function()
                local newText = ("%s [%d/%d]"):format(plr.Name, math.floor(hum.Health), math.floor(hum.MaxHealth))
                esp:SetText(newText)
            end))
        end
    end

    -- Hook existing character
    if plr.Character then
        onCharacterAdded(plr.Character)
    end

    -- Listen for respawns
    table.insert(espConns, plr.CharacterAdded:Connect(onCharacterAdded))
end

-- Toggle
ESPBox:AddToggle("PlayersESP", {
    Text    = "PlayersESP",
    Default = false,
}):OnChanged(function(on)
    clearPlayers()
    if not on then return end

    -- Add ESP for all current players
    for _, plr in ipairs(Players:GetPlayers()) do
        addPlayer(plr)
    end
    -- Hook new players joining
    table.insert(espConns, Players.PlayerAdded:Connect(addPlayer))
    -- Clear ESP when players leave
    table.insert(espConns, Players.PlayerRemoving:Connect(function(leaving)
        if espItems[leaving] then
            ESPLibrary:RemoveESP(espItems[leaving])
            espItems[leaving] = nil
        end
    end))
end)


do
     ReplicatedStorage = game:GetService("ReplicatedStorage")
     Workspace         = game:GetService("Workspace")

    -- Shortcut to your game data and room folder
     GameData     = ReplicatedStorage:WaitForChild("GameData")
     LatestRoomVal = GameData:WaitForChild("LatestRoom")
     CurrentRooms  = Workspace:WaitForChild("CurrentRooms")

    -- The set of item names you want to ESP
     items = {
        "Flashlight","Lockpick","Vitamins","Bandage","StarVial","StarBottle","StarJug",
        "Shakelight","Straplight","Bulklight","Battery","Candle","Crucifix","CrucifixWall",
        "Glowsticks","SkeletonKey","Candy","ShieldMini","ShieldBig","BandagePack","BatteryPack",
        "RiftCandle","LaserPointer","HolyGrenade","Shears","Smoothie","Cheese","Bread",
        "AlarmClock","RiftSmoothie","GweenSoda","GlitchCub","GoldPile",
    }
    local itemSet = {}
    for i = 1, #items do
        itemSet[items[i]] = true
    end

    -- Storage for ESP handles and connections
    local trackedItems = {}   -- [Instance] = espHandle
    local descConns    = {}   -- { addConn, removeConn }
    local roomChangedConn

    -- Helper to clear everything
    local function clearAll()
        for inst, esp in pairs(trackedItems) do
            ESPLibrary:RemoveESP(esp)
        end
        trackedItems = {}

        for i = 1, #descConns do
            descConns[i]:Disconnect()
        end
        descConns = {}
    end

    -- Get the currently active room instance
    local function currentRoom()
        return CurrentRooms:FindFirstChild(tostring(LatestRoomVal.Value))
    end

    -- Add ESP on a single descendant
    local function addItem(inst)
        if trackedItems[inst] then return end
        local part = inst:IsA("BasePart") and inst
                  or (inst.PrimaryPart or inst:FindFirstChildWhichIsA("BasePart"))
        if not part then return end

        local esp = ESPLibrary:AddESP{
            Object = part,
            Text   = inst.Name,
            Color  = Color3.fromRGB(255,215,0),
        }
        trackedItems[inst] = esp
    end

    -- Remove ESP for a single descendant
    local function removeItem(inst)
        local esp = trackedItems[inst]
        if esp then
            ESPLibrary:RemoveESP(esp)
            trackedItems[inst] = nil
        end
    end

    -- (Re)attach DescendantAdded/Removing on the given room
    local function bindRoom(room)
        -- initial scan
        local desc = room:GetDescendants()
        for i = 1, #desc do
            local d = desc[i]
            if itemSet[d.Name] then
                addItem(d)
            end
        end

        -- listen for new items
        local addConn = room.DescendantAdded:Connect(function(d)
            if itemSet[d.Name] then
                addItem(d)
            end
        end)

        -- remove ESP when item is removed
        local remConn = room.DescendantRemoving:Connect(function(d)
            if itemSet[d.Name] then
                removeItem(d)
            end
        end)

        descConns[1 + #descConns] = addConn
        descConns[1 + #descConns] = remConn
    end

    -- Setup ItemsESP toggle
    ESPBox:AddToggle("ItemsESP", {
        Text    = "ItemsESP",
        Default = false,
        Callback = function(on)
            -- cleanup any existing
            clearAll()
            if roomChangedConn then
                roomChangedConn:Disconnect()
                roomChangedConn = nil
            end

            if not on then return end

            -- bind to the current room right now
            local room = currentRoom()
            if room then bindRoom(room) end

            -- re-bind whenever the room changes
            roomChangedConn = LatestRoomVal.Changed:Connect(function()
                clearAll()
                local newRoom = currentRoom()
                if newRoom then bindRoom(newRoom) end
            end)
        end,
    })
end
ESPSettings:AddToggle('Rainbow ESP',{
	Text = "Rainbow Esp",
	Default = false,
	Callback = function(Value)
		ESPLibrary:SetRainbow(Value)
	end
})
ESPSettings:AddToggle('Traces ESP',{
	Text = "Tracers Esp",
	Default = false,
	Callback = function(Value)
		ESPLibrary:SetTracers(Value)
	end
})
ESPSettings:AddToggle('Distance Meters ESP',{
	Text = "Distance Meters Esp",
	Default = false,
	Callback = function(Value)
		ESPLibrary:SetShowDistance(Value)
	end
})

ESPSettings:AddSlider('Text Size',{
	Text='Text Size',
	Min=18,Max=29,Default=20,
	Rounding=0,
	Callback=function(v)
		ESPLibrary:SetTextSize(v)
	end
})
local Toggle10 = AntiBox:AddToggle('AntiJamming', {
	Text = "Anti-Jamming",
	Default = false,
	Callback = function(state)
		if not game:GetService("ReplicatedStorage").LiveModifiers.Jammin then return end
		local mainTrack = SoundService:FindFirstChild("Main")
		if mainTrack then
			local jamming = mainTrack:FindFirstChild("Jamming")
			if jamming then
				jamming.Enabled = not state
			end
		end

		local mainUI = LocalPlayer:FindFirstChild("PlayerGui")
			and LocalPlayer.PlayerGui:FindFirstChild("MainUI")
		if mainUI then
			local healthGui = mainUI:FindFirstChild("Initiator")
				and mainUI.Initiator:FindFirstChild("Main_Game")
				and mainUI.Initiator.Main_Game:FindFirstChild("Health")
			if healthGui then
				local jamSound = healthGui:FindFirstChild("Jam")
				if jamSound then
					jamSound.Playing = not state
				end
			end
		end
	end
})

-- FOV Slider and Toggle

-- Services
-- Services
local Players       = game:GetService("Players")
local Workspace     = game:GetService("Workspace")

local LocalPlayer   = Players.LocalPlayer
local camera        = Workspace.CurrentCamera

local currentFOV    = 70      -- always reflects camera.FieldOfView
local targetFOV     = 70      -- slider’s value, updated even when disabled
local fovEnabled    = false
local stepping      = false

-- step the FOV by 5 towards targetFOV every 0.08s
local function stepFOV()
    if stepping then return end
    stepping = true

    task.spawn(function()
        while stepping and currentFOV ~= targetFOV do
            local delta = targetFOV - currentFOV
            local step  = (delta > 0 and 5) or -5
            -- if overshoot, clamp to exact
            if math.abs(delta) < 5 then
                step = delta
            end

            currentFOV = currentFOV + step
            camera.FieldOfView = currentFOV

            task.wait(0.002)
        end
        stepping = false
    end)
end

-- enforce that nothing else can claw FOV away
local fovConn
local function startEnforcing()
    if fovConn then fovConn:Disconnect() end
    fovConn = camera:GetPropertyChangedSignal("FieldOfView"):Connect(function()
        if math.abs(camera.FieldOfView - currentFOV) > 0.1 then
            camera.FieldOfView = currentFOV
        end
    end)
end
local function stopEnforcing()
    if fovConn then fovConn:Disconnect() fovConn = nil end
end

-- Slider just updates targetFOV, and if enabled, kicks off a step
ESPSettings:AddSlider("FOV", {
    Text     = "Field of View",
    Min      = 70,
    Max      = 120,
    Default  = 70,
    Rounding = 0,
    Callback = function(value)
        targetFOV = value
        if fovEnabled then
            stepFOV()
        end
    end,
})

-- Toggle turns enforcement & stepping on/off, and always steps to the slider’s value on turn-on
ESPSettings:AddToggle("EnableFOV", {
    Text    = "Enable Field of View",
    Default = false,
    Callback = function(on)
        fovEnabled = on

        if on then
            startEnforcing()
            -- make camera move from wherever it is now **toward** targetFOV
            currentFOV = camera.FieldOfView
            stepFOV()
        else
            stopEnforcing()
            -- step back down to 70 (but don’t reset targetFOV!) 
            targetFOV = 70
            stepFOV()
        end
    end,
})

-- === ANTI FOG (tweened) ===
do
    local Lighting     = game:GetService("Lighting")
local TweenService = game:GetService("TweenService")
local atmosphere   = Lighting:FindFirstChildOfClass("Atmosphere")

-- Will hold the original density once we first enable AntiFog
local cachedDensity = nil

-- Flag to control the loop
local antiFogActive = false

AntiBox:AddToggle("AntiFog", {
    Text    = "Anti Fog",
    Default = false,
    Callback = function(enabled)
        if not atmosphere then
            return
        end

        antiFogActive = enabled

        if enabled then
            -- Cache the original density on first enable
            if cachedDensity == nil then
                cachedDensity = atmosphere.Density
            end

            -- Spawn a single loop that keeps setting Density = 0
            task.spawn(function()
                while antiFogActive do
                    -- Tween to zero density
                    TweenService:Create(
                        atmosphere,
                        TweenInfo.new(0.5),
                        { Density = 0 }
                    ):Play()

                    task.wait(0.8)
                end
            end)
        else
            -- Restoring the cached density when disabled
            if cachedDensity then
                TweenService:Create(
                    atmosphere,
                    TweenInfo.new(0.5),
                    { Density = cachedDensity }
                ):Play()
            end
        end
    end,
})
end

-- === ANTI LAG (destroy lights) ===
do
    local LightNames = { LightStand = true, LightFixture = true }
    local destroyConn

    AntiBox:AddToggle("AntiLag", {
        Text    = "Anti Lag (Remove Lights)",
        Default = false,
        Callback = function(on)
            -- Disconnect any existing listener
            if destroyConn then
                destroyConn:Disconnect()
                destroyConn = nil
            end

            if not on then
                return
            end

            -- 1) Batched initial scan
            task.spawn(function()
                local allDescendants = roomsFolder:GetDescendants()
                local batchSize = 20
                for i = 1, #allDescendants, batchSize do
                    for j = i, math.min(i + batchSize - 1, #allDescendants) do
                        local obj = allDescendants[j]
                        if LightNames[obj.Name] and obj:IsA("BasePart") then
                            obj:Destroy()
                        end
                    end
                    task.wait()
                end
            end)

            -- 2) Listen for new lights being added
            destroyConn = roomsFolder.DescendantAdded:Connect(function(obj)
                if LightNames[obj.Name] then
                    obj:Destroy()
                end
            end)
        end,
    })
end

-- === DELETE FIGURE (FE) ===
do
    seenModels = {}
    destroyConn = {}
    figureConn = nil
    roomFolder = workspace.CurrentRooms
    DeleteFigureEnabled = false

    function notify(msg)
        Library:Notify(msg, 3)
    end

    function handleFigure(model)
        if seenModels[model] then return end
        seenModels[model] = true

        destroyConn[model] = model.AncestryChanged:Connect(function(_, parent)
            if not parent then
                seenModels[model] = nil
                if destroyConn[model] then
                    destroyConn[model]:Disconnect()
                    destroyConn[model] = nil
                end
            end
        end)

        task.spawn(function()
            while DeleteFigureEnabled do
            task.wait(0.02)
                ppart = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
                if model.Root and model.Parent and isnetworkowner(model.Root) then
                    d = model:GetDescendants()
                    for i = 1, #d do
                        v = d[i]
                        if v:IsA("BasePart") then
                            v.CanCollide = false
                            v.CFrame = CFrame.new(0,-math.huge, 0)
                        end
                    end
                    notify(model.Name .. " has been cleared!")
                    return
                end
            end
        end)
    end

    BypassBox:AddToggle("DFF", {
        Text = "Delete Figure (FE)",
        Default = false,
        Callback = function(on)
            DeleteFigureEnabled = on

            if figureConn then figureConn:Disconnect() figureConn = nil end
            for m, c in pairs(destroyConn) do if c then c:Disconnect() end end
            table.clear(seenModels)
            table.clear(destroyConn)

            if on then
                notify(" Some times Require  Clock…")

                task.spawn(function()
                    dList = roomFolder:GetDescendants()
                    for i = 1, #dList, 3000 do
                        for j = i, math.min(i + 3000 #dList) do
                            m = dList[j]
                            if m:IsA("Model") and (m.Name == "FigureRig" or m.Name == "FigureRagdoll") then
                                handleFigure(m)
                            end
                        end
                        task.wait()
                    end
                end)

                figureConn = roomFolder.DescendantAdded:Connect(function(m)
                    if m:IsA("Model") and (m.Name == "FigureRig" or m.Name == "FigureRagdoll") then
                        handleFigure(m)
                    end
                end)
            else
                notify("Delete Figure disabled.")
            end
        end,
    })
local shade = game:GetService("ReplicatedStorage").ClientModules.EntityModules:FindFirstChild("_Shade")
	or game:GetService("ReplicatedStorage").ClientModules.EntityModules:FindFirstChild("Shade")

AntiBox:AddToggle('AN',{
	Text = "Anti Halt",
	Default = false,
	Callback = function(on)
		if shade then
			shade.Name = on and "_Shade" or "Shade"
		end
	end
})
local Void = game:GetService("ReplicatedStorage").ClientModules.EntityModules:FindFirstChild("_Void")
	or game:GetService("ReplicatedStorage").ClientModules.EntityModules:FindFirstChild("Void")

AntiBox:AddToggle('AVJ',{
	Text = "Anti Void JumpScare",
	Default = false,
	Callback = function(on)
		if Void then
			Void.Name = on and "_Void" or "Void"
		end
	end
})
local Glitch = game:GetService("ReplicatedStorage").ClientModules.EntityModules:FindFirstChild("_Glitch")
	or game:GetService("ReplicatedStorage").ClientModules.EntityModules:FindFirstChild("Glitch")

AntiBox:AddToggle('AGJ',{
	Text = "Anti Glitch JumpScare",
	Default = false,
	Callback = function(on)
		if Glitch then
			Glitch.Name = on and "_Glitch" or "Glitch"
		end
	end
})


-- Find CamLock once, with an indexed loop and early break


-- Services
local RunService      = game:GetService("RunService")
local ReplicatedStore = game:GetService("ReplicatedStorage")
local Players         = game:GetService("Players")
local Workspace       = game:GetService("Workspace")

local LocalPlayer     = Players.LocalPlayer

--------------------------------------------------------------------------------
-- 1) FAST CLOSET EXIT (FCE) with batched CamLock cache & movement-start detection
--------------------------------------------------------------------------------
-- Cache all RemoteEvents named "CamLock" once (batched over frames)
local CamLockEvents = {}
task.spawn(function()
	local desc     = ReplicatedStore:GetDescendants()
	local batchMax = 15
	for i = 1, #desc, batchMax do
		for j = i, math.min(i + batchMax - 1, #desc) do
			local obj = desc[j]
			if obj:IsA("RemoteEvent") and obj.Name == "CamLock" then
				table.insert(CamLockEvents, obj)
			end
		end
		task.wait()
	end
end)

do
	local FastValue = Instance.new("BoolValue")
	FastValue.Name   = "FastClosetToggle"
	FastValue.Parent = LocalPlayer

	local lastDir = Vector3.zero
	local conn

	BypassBox:AddToggle('FCE', {
		Text    = 'Closet Exit Fix',
		Default = false,
		Tooltip = "Fixes Where you Cant Exit Closet Instantly After Hiding",
		Callback = function(on)
			FastValue.Value = on
			if conn then conn:Disconnect() conn = nil end

			if on then
				conn = RunService.Heartbeat:Connect(function()
					 char = LocalPlayer.Character
					 humanoid = char and char:FindFirstChild("Humanoid")
					if not humanoid then return end

					 dir = humanoid.MoveDirection
					if dir.Magnitude > 0 and lastDir.Magnitude == 0 and char:GetAttribute("Hiding") == true then
						task.delay(0.08,function()        for _, evt in ipairs(CamLockEvents) do
							evt:FireServer()
						end
					end)
					end
					lastDir = dir
				end)
			end
		end,
	})
end

--------------------------------------------------------------------------------
-- 2) ANTI SEEK FLOOD (ASF) â€” one-time disable when room "100" appears
--------------------------------------------------------------------------------
----- VARIABLES / SETUP -----

do
	local conn
	MinesBox:AddToggle('ASF', {
		Text    = "Anti-Seek Flood",
		Default = false,
		Callback = function(on)
			if conn then conn:Disconnect() conn = nil end
			if not on then return end

			conn = RunService.Heartbeat:Connect(function()
				 room = Workspace.CurrentRooms:FindFirstChild("100")
				if not room then return end
				conn:Disconnect() conn = nil

				 damHandler = room:FindFirstChild("_DamHandler")
				if damHandler then
					for _, obj in ipairs(damHandler:GetDescendants()) do
						if obj.Name == "SeekFloodline" and obj:IsA("BasePart") then
							obj.CanCollide = false
							obj.CanTouch = false
						end
					end
				end
			end)
		end,
	})
end

--------------------------------------------------------------------------------
-- 3) ANTI JEFF (AJF) â€” track JeffTheKiller models and kill owned ones
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- 4) ANTI BRIDGE FALL (ABF) â€” batched initial scan + event-driven barrier clones
--------------------------------------------------------------------------------
do
	local clones      = {}
	local bridgeConns = {}

	 function makeBarrier(barrier)
		if barrier.Parent:FindFirstChild("AntiBridge") then return end
		local clone = barrier:Clone()
		clone.Name         = "AntiBridge"
		clone.Size         = Vector3.new(barrier.Size.X, barrier.Size.Y, 30)
		clone.Color        = Color3.new(1,1,1)
		clone.CFrame       = barrier.CFrame * CFrame.new(0,0,-5)
		clone.Transparency = 0
		clone.Parent       = barrier.Parent
		table.insert(clones, clone)
	end

	 function watchBridge(bridge)
		-- clone existing barriers
		for _, part in ipairs(bridge:GetChildren()) do
			if part.Name == "PlayerBarrier"
				and part.Size.Y == 2.75
				and (part.Rotation.X % 180) == 0 then
				makeBarrier(part)
			end
		end
		-- listen for new barriers
		local conn = bridge.ChildAdded:Connect(function(c)
			if c.Name == "PlayerBarrier" then
				makeBarrier(c)
			end
		end)
		table.insert(bridgeConns, conn)
	end

	MinesBox:AddToggle('ABF', {
		Text    = "Anti-Bridge Fall",
		Default = false,
		Callback = function(on)
			-- teardown
			for _, c in ipairs(bridgeConns) do c:Disconnect() end
			bridgeConns = {}
			for _, c in ipairs(clones) do if c.Parent then c:Destroy() end end
			clones = {}

			if not on then return end

			-- batched initial bridge scan
			task.spawn(function()
				 rooms = Workspace.CurrentRooms:GetChildren()
				 batch = 10
				for i = 1, #rooms, batch do
					for j = i, math.min(i+batch-1, #rooms) do
						 parts = rooms[j]:FindFirstChild("Parts")
						if parts then
							for _, bridge in ipairs(parts:GetChildren()) do
								if bridge.Name == "Bridge" then
									watchBridge(bridge)
								end
							end
						end
					end
					task.wait()
				end
			end)

			-- listen for new Bridges in existing rooms
			for _, room in ipairs(Workspace.CurrentRooms:GetChildren()) do
				 parts = room:FindFirstChild("Parts")
				if parts then
					local conn = parts.ChildAdded:Connect(function(c)
						if c.Name == "Bridge" then
							watchBridge(c)
						end
					end)
					table.insert(bridgeConns, conn)
				end
			end

			-- listen for new rooms
			local roomsConn = Workspace.CurrentRooms.ChildAdded:Connect(function(r)
				local parts = r:WaitForChild("Parts", 5)
				if parts then
					local conn = parts.ChildAdded:Connect(function(c)
						if c.Name == "Bridge" then
							watchBridge(c)
						end
					end)
					table.insert(bridgeConns, conn)
				end
			end)
			table.insert(bridgeConns, roomsConn)
		end,
	})
end
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace         = game:GetService("Workspace")
local GameData          = ReplicatedStorage:WaitForChild("GameData")
local LatestRoomVal     = GameData:WaitForChild("LatestRoom")

-- Find the breaker remote once
local BreakerRemote
local descs = ReplicatedStorage:GetDescendants()
for i = 1, #descs do
    if descs[i].Name == "EBF" then
        BreakerRemote = descs[i]
        break
    end
end

local stopSignal = true

AutoBox:AddToggle("ABS", {
    Text    = "Auto Breaker Solve",
    Default = false,
    Callback = function(on)
        stopSignal = not on
        if on and BreakerRemote then
            task.spawn(function()
                while not stopSignal do
                    -- get the room you’re actually in
                    local roomName = tostring(LatestRoomVal.Value)
                    local room = Workspace.CurrentRooms:FindFirstChild(roomName)
                    if room then
                        local door = room:FindFirstChild("DoorToBreakDown")
                        if door then
                            BreakerRemote:FireServer()
                        end
                    end
                    task.wait(0.1)
                end
            end)
        end
    end,
})

--- SERVICES

-------------------------------------------------------------------
-- SERVICES
-------------------------------------------------------------------
local RepStorage         = game:GetService("ReplicatedStorage")
local Players            = game:GetService("Players")
local RunService         = game:GetService("RunService")
local PathfindingService = game:GetService("PathfindingService")

local LocalPlayer  = Players.LocalPlayer
local LatestRoom   = RepStorage.GameData.LatestRoom

if getconnections or get_signal_cons then
	for _, c in pairs((getconnections or get_signal_cons)(LocalPlayer.Idled)) do
		if c.Disable then c:Disable() elseif c.Disconnect then c:Disconnect() end
	end
end

local folder = workspace:FindFirstChild("PathFindPartsFolder")
if folder then folder:Destroy() end
folder = Instance.new("Folder", workspace)
folder.Name = "PathFindPartsFolder"
local visuals = {}

local WaypointSpacingSlider = RoomsBox:AddSlider("WaypointSpacing", {
	Text     = "Waypoint Spacing",
	Min      = 1,
	Max      = 10,
	Default  = 2,
	Rounding = 0,
})
local AutoRoomsToggle = RoomsBox:AddToggle("AR", { Text = "Auto A-1000", Default = false })
local DebugToggle     = RoomsBox:AddToggle("ARDBG", { Text = "Auto A-1000 Debug", Default = false })

local lastNotify = 0
local function throttleNotify(msg, dur)
	local now = tick()
	if now - lastNotify >= 1 then
		lastNotify = now
		Library:Notify(msg, dur)
	end
end

local function getLockerPart()
	local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	if not root then
		if DebugToggle.Value then throttleNotify("getLockerPart: HRP not found",2) end
		return
	end
	local closest, minD = nil, math.huge
	local desc = workspace.CurrentRooms:GetDescendants()
	for i = 1, #desc do
		local m = desc[i]
		if m.Name == "Rooms_Locker" and m:IsA("Model") and m.PrimaryPart and m:FindFirstChild("HidePrompt") and m:FindFirstChild("HiddenPlayer").Value == nil then
			local d = (root.Position - m.PrimaryPart.Position).Magnitude
			if d < minD then closest, minD = m.PrimaryPart, d end
		end
	end
	if not closest and DebugToggle.Value then throttleNotify("Locker part not found!",2) end
	return closest
end

local function getDoorPart()
	local room = workspace.CurrentRooms:FindFirstChild(LatestRoom.Value)
	if room then
		local d = room:FindFirstChild("Door")
		if d then return d:FindFirstChild("Door") end
	end
	if DebugToggle.Value then throttleNotify("getDoorPart failed",2) end
end

local waypoints, index, hiding = {}, 1, false

local function computePath(destPart)
	if not destPart or not AutoRoomsToggle.Value then return end
	local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then if DebugToggle.Value then throttleNotify("computePath: HRP missing",2) end return end
	local origin = hrp.Position - Vector3.new(0,2.5,0)
	local path = PathfindingService:CreatePath{
		WaypointSpacing = WaypointSpacingSlider.Value,
		AgentRadius     = 3,
		AgentCanJump    = false,
	}
	path:ComputeAsync(origin, destPart.Position)
	if path.Status ~= Enum.PathStatus.Success then
		if DebugToggle.Value then throttleNotify("Path failed: "..tostring(path.Status),2) end
		return
	end
	local wps = path:GetWaypoints()
	waypoints, index = wps, 1
	for i = 1, #wps do
		local wp = wps[i]
		local part = visuals[i] or Instance.new("Part", folder)
		visuals[i] = part
		part.Size       = Vector3.new(2,2,2)
		part.Shape      = Enum.PartType.Ball
		part.Material   = Enum.Material.SmoothPlastic
		part.Anchored   = true
		part.CanCollide = false
		part.CFrame     = CFrame.new(wp.Position)
	end
	for i = #wps+1, #visuals do
		visuals[i].Parent = nil
	end
	if #wps > 0 then
		LocalPlayer.Character.Humanoid:MoveTo(wps[1].Position)
	end
end

local function onMoveFinished(reached)
	if not reached then
		if DebugToggle.Value then throttleNotify("Stuck, recalculating...",1) end
		return computePath(hiding and getLockerPart() or getDoorPart())
	end
	index = index + 1
	if index <= #waypoints then
		LocalPlayer.Character.Humanoid:MoveTo(waypoints[index].Position)
	else
		if hiding then
			local lm = getLockerPart() and getLockerPart().Parent
			if lm and lm:FindFirstChild("HidePrompt") then
				fireproximityprompt(lm.HidePrompt)
				LocalPlayer.Character:SetAttribute("Hiding", true)
				if DebugToggle.Value then throttleNotify("Hiding now",2) end
			else
				if DebugToggle.Value then throttleNotify("HidePrompt not found",2) end
			end
		else
			if tonumber(LatestRoom.Value) == 1000 then throttleNotify("Congratulations on A-1000!",5) end
			if DebugToggle.Value then throttleNotify("Reached door",1) end
		end
	end
end

Players.LocalPlayer.CharacterAdded:Connect(function()
	waypoints, index, hiding = {}, 1, false
end)
LocalPlayer.Character:WaitForChild("Humanoid").MoveToFinished:Connect(onMoveFinished)

local function updateBehavior()
	if not AutoRoomsToggle.Value then return end
	local children = workspace:GetChildren()
	local found = false
	for i = 1, #children do
		local c = children[i]
		local n = c.Name
		if n == "A60" or n == "A-60" or n == "A120" or n == "A-120" then
			found = true
			break
		end
	end
	if found then
		hiding = true
		computePath(getLockerPart())
	else
		if hiding then
			hiding = false
			LocalPlayer.Character:SetAttribute("Hiding", false)
			computePath(getDoorPart())
		end
	end
end

workspace.ChildAdded:Connect(function(c)
	local n = c.Name
	if (n == "A60" or n == "A-60" or n == "A120" or n == "A-120") and AutoRoomsToggle.Value then
		updateBehavior()
	end
end)

workspace.ChildRemoved:Connect(function(c)
	local n = c.Name
	if (n == "A60" or n == "A-60" or n == "A120" or n == "A-120") and hiding then
		updateBehavior()
	end
end)

LatestRoom:GetPropertyChangedSignal("Value"):Connect(function()
	if not hiding then computePath(getDoorPart()) end
	updateBehavior()
end)

local autoRoomsLoop
AutoRoomsToggle:OnChanged(function(on)
	waypoints, index, hiding = {}, 1, false
	for _, p in ipairs(visuals) do p.Parent = nil end
	if on then
		computePath(getDoorPart())
		updateBehavior()
		autoRoomsLoop = task.spawn(function()
			while AutoRoomsToggle.Value do
			if LatestRoom.Value  == 1000 then break end
				computePath(hiding and getLockerPart() or getDoorPart())
				task.wait(1)
			end
		end)
	else
		autoRoomsLoop = nil
	end
end)
Library:SetWatermarkVisibility(true)

-- Example of dynamically-updating watermark with common traits (fps and ping)
local FrameTimer = tick()
local FrameCounter = 0;
local FPS = 60;

local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
	FrameCounter = FrameCounter + 1;

	if (tick() - FrameTimer) >= 1 then
		FPS = FrameCounter;
		FrameTimer = tick();
		FrameCounter = 0;
	end;

	Library:SetWatermark(('ProHax V2 | %s fps | %s ms'):format(
		math.floor(FPS),
		math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
		));
end);
Players      = game:GetService("Players")
LocalPlayer  = Players.LocalPlayer


-- Button always calls Func when clicked, so the â€œenabledâ€‌ check was removed.

AutoBox:AddButton({
	Text    = "Get Glitch Fragment",
	Default = false,
	Func = function()
		-- Grab or wait for the character and HRP only once
		local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
		local hrp  = char:WaitForChild("HumanoidRootPart")            -- î¨پ0î¨‚

		-- Bail if already at max
		local level = LocalPlayer:GetAttribute("GlitchLevel") or 0     -- î¨پ1î¨‚
		if level >= 5 then
			Library:Notify("Glitch Fragment Already Obtained")
			return
		end

		-- Precompute nudge vector and step delay
		local nudge   = Vector3.new(90, 0, 0)
		local delay   = 0.006

		-- Nudge forward until level hits 5
		repeat
			hrp.CFrame = workspace.SpawnLocation.CFrame - CFrame.new(90, 99,0)     -- small speedâ€گup by using CFrame.new multiplication î¨پ2î¨‚
			task.wait(delay)
			level = LocalPlayer:GetAttribute("GlitchLevel") or level
		until level >= 5

		Library:Notify("Glitch Fragment Successfully Gotten")
	end
})



SettingsBox:AddToggle("ShowKeybinds", {
	Text = "Show Keybinds",
	Default = true,
	Tooltip = "Toggle the visibility of the keybinds menu",
}):OnChanged(function()
	Library.KeybindFrame.Visible = Toggles.ShowKeybinds.Value
end)
SettingsBox:AddToggle("Dieanleksj", {
	Text = "Disables Roblox Void",
	Default = true,
	Tooltip = "Disables Void",
}):OnChanged(function()
	workspace.FallenPartsDestroyHeight =0/0
end)
SettingsBox:AddToggle("CustomCursor", {
	Text = "Custom Cursor",
	Default = true,
	Tooltip = "Toggle the visibility of the keybinds menu",
}):OnChanged(function()
	Library.ShowCustomCursor = Toggles.CustomCursor.Value
end)


local Contributors = Tabs.UISettings:AddRightGroupbox("Credits")
Contributors:AddLabel("KardinCat - Creator",true)
Contributors:AddLabel("bocaj111004 - Helped me With Some Features",true)
-- UI Settings
SaveManager:IgnoreThemeSettings()
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
ThemeManager:ApplyToTab(Tabs.UISettings)
SaveManager:SetFolder('ProHax')
SaveManager:SetIgnoreIndexes({'MenuKeybind'})
SaveManager:BuildConfigSection(Tabs.UISettings)
-- SERVICES (globals only for late-binding patterns)
Players         = game:GetService("Players")
RunService      = game:GetService("RunService")
ReplicatedStore = game:GetService("ReplicatedStorage")

-- SHARED
player          = Players.LocalPlayer
camera          = workspace.CurrentCamera
GameData        = ReplicatedStore:WaitForChild("GameData")
LatestRoom      = GameData:WaitForChild("LatestRoom")
RemotesFolder   = ReplicatedStore:FindFirstChild("RemotesFolder") and ReplicatedStore.RemotesFolder:FindFirstChild("Underwater") or nil

-- CONSTANTS (globals OK)
ANCHOR_NAME        = "ClientNetAnchor_"
VELOCITY_MAG       = 0.1
ROT_SPEED_DEG      = 0.2
CAM_OFFSET         = Vector3.new(0,5,6)
SAFE_DELAY         = 1
FALL_HEIGHT        = 0/0

-- CONNECTION STORAGE
Conn = {}
transparencyConns = {}

-- UTILITY: destroy old anchor
function cleanupOldAnchor()
    old = workspace:FindFirstChild(ANCHOR_NAME)
    if old then old:Destroy() end
end

-- ANCHOR CREATION & OWNERSHIP–NUDGE
function createClientAnchor(rootPart)
    cleanupOldAnchor()
    anchor = Instance.new("Part")
    anchor.Name, anchor.Size, anchor.Transparency, anchor.CanCollide, anchor.Anchored, anchor.CFrame = 
        ANCHOR_NAME, Vector3.new(.5,.5,.5), 1, false, false, rootPart.CFrame
    anchor.Parent = workspace
    weld = Instance.new("WeldConstraint", anchor)
    weld.Part0, weld.Part1 = anchor, rootPart

    conn = RunService.RenderStepped:Connect(function()
        if not anchor.Parent or not rootPart.Parent then conn:Disconnect() return end
        anchor.Velocity   = Vector3.new(VELOCITY_MAG,0,0)
        anchor.CFrame     = anchor.CFrame * CFrame.Angles(0,math.rad(ROT_SPEED_DEG),0)
    end)
end

-- CHARACTER BIND
function onCharacterAdded(char)
    root = char:WaitForChild("HumanoidRootPart",5)
    if root then task.wait(.1) createClientAnchor(root) end
end
player.CharacterAdded:Connect(onCharacterAdded)
cleanupOldAnchor()

-- CAMERA LOCK
cameraLocked = false
function enableCameraLock()
    camera.CameraType = Enum.CameraType.Scriptable
    RunService:UnbindFromRenderStep("CameraFollow")
    RunService:BindToRenderStep("CameraFollow", Enum.RenderPriority.Camera.Value+1, function()
        root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        if root then
            target = root.Position + Vector3.new(0,2,0)
            worldOff = root.CFrame:VectorToWorldSpace(CAM_OFFSET)
            camera.CFrame = CFrame.new(target+worldOff, target)
        end
    end)
    cameraLocked = true
end
function disableCameraLock()
    RunService:UnbindFromRenderStep("CameraFollow")
    camera.CameraType = Enum.CameraType.Custom
    cameraLocked = false
end

-- CLEANUP DEATH UI
function cleanDeathUI()
    gui = player:FindFirstChild("PlayerGui")
    if not gui then return end
    main = gui:FindFirstChild("MainUI")
    if not main then return end
    for _,n in ipairs({"DeathPanel","Death"}) do
        obj = main:FindFirstChild(n)
        if obj then obj:Destroy() end
    end
end

-- ENLARGE “KeyObtain”
function enlargeKeyObtainParts()
    rooms = workspace:WaitForChild("CurrentRooms")
    function proc(v)
        if v.Name=="KeyObtain" and v.PrimaryPart then
            v.PrimaryPart.Size = v.PrimaryPart.Size* 6
        end
    end
    for _,v in ipairs(rooms:GetDescendants()) do proc(v) end
    Conn.enlarge = rooms.DescendantAdded:Connect(proc)
end

-- DOOR CF FETCH
function getLatestRoomDoorCFrame()
    name = LatestRoom.Value
    room = workspace.CurrentRooms:FindFirstChild(name)
    if not room then
        root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        return root and root.CFrame
    end
    door = room:FindFirstChild("Door") or room.PrimaryPart
    return door and door.CFrame or player.Character.HumanoidRootPart.CFrame
end

-- FAKE DEATH SEQUENCE
function performFakeDeath()
    workspace.FallenPartsDestroyHeight = FALL_HEIGHT
    char = player.Character or player.CharacterAdded:Wait()
    humanoid = char:WaitForChild("Humanoid",5)
    root     = char:WaitForChild("HumanoidRootPart",5)
    workspace.Gravity = 0
    cleanDeathUI()
    enlargeKeyObtainParts()
    repeat UnderwaterRemote:FireServer(true); task.wait(.2) until humanoid.Health<=0
    for i=1,5 do UnderwaterRemote:FireServer(false); task.wait(.1) end
    if player:GetAttribute("Alive")==false then player:SetAttribute("Alive",true) end
    humanoid.Health = humanoid.MaxHealth
    start = tick()
    repeat task.wait(.05) until humanoid.Health>1 or tick()-start>2
    targetCF = getLatestRoomDoorCFrame()
root.CFrame = targetCF 
task.wait(SAFE_DELAY)

root.CFrame = targetCF
    humanoid.PlatformStand = false
    humanoid.AutomaticScalingEnabled = true
    humanoid:ChangeState(Enum.HumanoidStateType.GettingUp); task.wait(.1)
    humanoid:ChangeState(Enum.HumanoidStateType.Running)
    if char:GetAttribute("Stunned")~=nil or char:GetAttribute("InCutscene")~=nil then
        local t0 = tick()
        while tick()-t0<2 do
            char:SetAttribute("Stunned",false)
            char:SetAttribute("InCutscene",false)
            task.wait(.1)
        end
    end
    workspace.Gravity = 90
    if cameraLocked then enableCameraLock() end
    -- fallback
    cf = getLatestRoomDoorCFrame()
    -- Teleport to target immediately…
root.CFrame = cf
-- …wait a frame for physics/replication…
task.wait(SAFE_DELAY)
-- …and reapply to ensure stability
root.CFrame = cf
    -- re-enable DrawerContainer prompts
    for _,v in ipairs(workspace:GetDescendants()) do
        if v:IsA("ProximityPrompt") and v.Parent.Name=="DrawerContainer" then
            v.Enabled = true
        end
    end
end

BypassBox:AddToggle("Fake Death", {
    Text    = "Fake Death",
    Default = false,
    Tooltip = "Make you invincible (costly)",
    Risky   = true,
    Callback= function(on) if on then performFakeDeath() end end,
})

-- THIRD-PERSON VIEW

  ReplicatedStore = game:GetService("ReplicatedStorage")
Players         = game:GetService("Players")
player          = Players.LocalPlayer

local SecondLiveConnection = nil
local OriginalGravity = workspace.Gravity

BypassBox:AddToggle("SecondLive", {
    Text    = "Second Live",
    Tooltip = "When you die, it uses fake death",
    Default = false,
    Callback = function(enabled)
        if SecondLiveConnection then
            SecondLiveConnection:Disconnect()
            SecondLiveConnection = nil
        end

        workspace.Gravity = OriginalGravity

        if enabled then
            local humanoid = player.Character and player.Character:FindFirstChild("Humanoid") or player.Character:WaitForChild("Humanoid")
            SecondLiveConnection = humanoid.Died:Connect(function()
                task.delay(0.5, function()
                    workspace.Gravity = 0

                    char = player.Character
                    if not char then return end

                    hum = char:FindFirstChild("Humanoid")
                    root = char:FindFirstChild("HumanoidRootPart")
                    if not hum or not root then return end

                    gui = player:FindFirstChild("PlayerGui")
                    if gui then
                        ui = gui:FindFirstChild("MainUI")
                        if ui then
                            d1 = ui:FindFirstChild("DeathPanel")
                            if d1 then d1:Destroy() end
                            d2 = ui:FindFirstChild("Death")
                            if d2 then d2:Destroy() end
                        end
                    end

                    hum.Health = hum.MaxHealth
                    hum.AutomaticScalingEnabled = true

                    if char:GetAttribute("Stunned") then
                        char:SetAttribute("Stunned", false)
                    end

                    room = ReplicatedStore.GameData.LatestRoom.Value
                    rm = workspace.CurrentRooms:FindFirstChild(room)
                    door = rm and rm:FindFirstChild("Door") and rm.Door:FindFirstChild("Door")
                    if door then
                        root.CFrame = door.CFrame + Vector3.new(0, 3, 0)
                        task.delay(1, function()
                            if SecondLiveConnection then
                                workspace.Gravity = OriginalGravity
                            end
                        end)
                    end
                end)
            end)
        end
    end,
})
local Players     = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local conn
local ignoreList = {}    -- list of CandyIDs to ignore
local ignoreSet  = {}    -- for O(1) checks



--––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
-- Toggle: Auto-eat any new Candy tools not in ignoreSet
--––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
AutoBox:AddToggle("AutoEatCandies", {
    Text    = "Auto Eat Candies",
    Tooltip = "Automatically eats candies",
    Default = false,

    Callback = function(enabled)
        if enabled then
            local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            conn = character.ChildAdded:Connect(function(child)
                if child:IsA("Tool") and child.Name == "Candy" then
                    
                        child.Remote:FireServer()
                end
            end)
        else
            if conn then
                conn:Disconnect()
                conn = nil
            end
        end
    end,
})
 -- Services
local Players           = game:GetService("Players")
local Workspace         = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Shortcut to the folder containing all rooms
local CurrentRooms = Workspace:WaitForChild("CurrentRooms")

-- Keep track of our listeners so we can disconnect on untoggle
local removeConns = {}

-- Helper: destroy all existing instances with the given name under all rooms
local function sweepExisting(targetName)
    local all = CurrentRooms:GetDescendants()
    for i = 1, #all do
        if all[i].Name == targetName then
            all[i]:Destroy()
        end
    end
end

-- Setup a single toggle that:
--  • on enable: sweeps existing + listens for ANY new descendant under CurrentRooms
--  • on disable: disconnects its listener
local function setupToggle(uiBox, key, targetName)
    local conn

    uiBox:AddToggle(key, {
        Text    = key,
        Default = false,
        Callback = function(on)
            -- turn off
            if conn then
                conn:Disconnect()
                conn = nil
            end

            if not on then
                return
            end

            -- initial sweep
            sweepExisting(targetName)

            -- listen for new instances anywhere under any room
            conn = CurrentRooms.DescendantAdded:Connect(function(inst)
                if inst.Name == targetName then
                    inst:Destroy()
                end
            end)
        end,
    })

    -- keep track so we can clean all at once if needed
    removeConns[key] = function()
        if conn then
            conn:Disconnect()
            conn = nil
        end
    end
end

-- Instantiate all your removal toggles:
setupToggle(FoolsBox,  "Remove-Banana",     "BananaPeel")
setupToggle(FoolsBox,  "Remove-JeffClient", "JeffTheKiller")
setupToggle(BackBox,   "Remove-Vacuum",     "SideroomSpace")
setupToggle(MinesBox,  "Remove-Giggle",     "GiggleCeiling")
setupToggle(MinesBox,  "Remove-GloomPile",  "GloomPile")
setupToggle(RetroBox,  "Remove-Lava",       "Lava")
setupToggle(RetroBox,  "Remove-ScaryWall",  "ScaryWall")
con = nil
FigureBodyPositions = {}

function handleFigureFreezeTarget(figure)
    local primary = figure.PrimaryPart
    repeat task.wait(0.2) until isnetworkowner(primary)
    local bp = Instance.new("BodyPosition", primary)
    bp.MaxForce = Vector3.new(1e30, 1e30, 1e30)
    bp.P = 9999999999
    bp.Position = primary.Position
    FigureBodyPositions[#FigureBodyPositions + 1] = bp
end

TrollBox:AddToggle("Figure Freeze", {
    Text    = "Figure Freeze (FE)",
    Default = false,
    Callback = function(Value)
        FigureFreeze = Value
        if Value then
            local room = workspace.CurrentRooms
            local descendants = room:GetDescendants()
            for i = 1, #descendants do
                local v = descendants[i]
                if v.Name == "FigureRig" or v.Name == "FigureRagdoll" then
                    handleFigureFreezeTarget(v)
                end
            end
            con = room.DescendantAdded:Connect(function(v)
                if v.Name == "FigureRig" or v.Name == "FigureRagdoll" then
                    handleFigureFreezeTarget(v)
                end
            end)
        else
            if con then
                con:Disconnect()
                con = nil
            end
            for i = 1, #FigureBodyPositions do
                local bp = FigureBodyPositions[i]
                if bp and bp.Parent then
                    bp:Destroy()
                end
            end
            FigureBodyPositions = {}
        end
    end
})
con = nil
RemotesFolder = nil

TrollBox:AddToggle("Spam MotorReplication (FE)", {
    Text    = "Spam MotorReplication (FE)",
    Default = false,
    Callback = function(Value)
        if Value then
            if ReplicatedStorage:FindFirstChild("EntityInfo") then
                RemotesFolder = ReplicatedStorage.EntityInfo
            else
                RemotesFolder = ReplicatedStorage.RemotesFolder
            end

            con = RunService.Heartbeat:Connect(function()
                RemotesFolder.MotorReplication:FireServer(-198182828, math.random(-12233333, 999999))
            end)
        else
            if con then
                con:Disconnect()
                con = nil
            end
        end
    end
})
-- Global tables to track ESP instances and connection

-- Global variable to hold the active RenderStepped connection (if any)
UpsideDownConnection = nil

-- Function: Starts flipping the character upside down every frame
function StartUpsideDown()
    -- Prevent multiple connections
    if UpsideDownConnection then
        return
    end

    -- Get the local player's character
    Character = game.Players.LocalPlayer.Character
    if not Character then
        return
    end

    -- Cache the part whose Rotation we want to match/override
    RotationPart = Character:FindFirstChild("Collision")
    if not RotationPart then
        return
    end

    -- Connect to RenderStepped for smooth, frame-synced rotation updates
    UpsideDownConnection = game:GetService("RunService").RenderStepped:Connect(function()
        -- Read the current rotation of the Collision part
        rotation = RotationPart.Rotation
        -- Apply the same X and Y rotation, but force Z = -90 to flip upside down
        Character.Rotation = Vector3.new(rotation.X, rotation.Y, -90)
    end)
end

-- Function: Stops flipping and resets rotation
function StopUpsideDown()
    if UpsideDownConnection then
        -- Disconnect the RenderStepped callback
        UpsideDownConnection:Disconnect()
        UpsideDownConnection = nil

        -- Reset the character's rotation to upright (0, 0, 0)
        if Character and Character.Parent then
            Character.Rotation = Vector3.new(0, 0, 0)
        end
    end
end

-- AddToggle implementation (FE-safe)


TrollBox:AddToggle("Upside Down (FE)", {
    Text    = "Upside Down (FE)",
    Default = false,
    Callback = function(enabled)
        if enabled then
            StartUpsideDown()
        else
            StopUpsideDown()
        end
    end
})
AntiBox:AddToggle("No CutScenes", {
    Text    = "No CutScenes",
    Default = false,
    Callback = function(enabled)
    if enabled then
    local CutScenes  = game:GetService("Players").LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game.RemoteListener:FindFirstChild("Cutscenes") or game:GetService("Players").LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game.RemoteListener:FindFirstChild("_Cutscenes")
CutScenes.Name = enabled and "_Cutscenes" or "Cutscenes"
end
end
})

MiscBox:AddButton({
	Text    = "Vitamin",
	DoubleClick = true,
	Func = function()
		Character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
Backpack = game.Players.LocalPlayer.Backpack

Vitamins = Instance.new("Tool", Backpack)
Vitamins.Name = "Vitamins"
Vitamins.TextureId = "rbxassetid://10482863785"

Handle = Instance.new("MeshPart", Vitamins)
Handle.Name = "Handle"
Handle.MeshId = "rbxassetid://10469363179"
Handle.Size = Vector3.new(0.02, 0.02, 0.02)

SoundEffect = Instance.new("Sound", Handle)
SoundEffect.SoundId = "rbxassetid://11405639640"

UseAnimation = Instance.new("Animation", Vitamins)
UseAnimation.AnimationId = "rbxassetid://10482563149"

Label = Instance.new("MeshPart", Handle)
Label.Name = "Label"
Label.MeshId = "rbxassetid://10469363500"

Lid = Instance.new("MeshPart", Handle)
Lid.Name = "Lid"
Lid.MeshId = "rbxassetid://10469363357"

Stuff = Instance.new("MeshPart", Handle)
Stuff.Name = "Stuff"
Stuff.MeshId = "rbxassetid://10469363693"

StuffTop = Instance.new("MeshPart", Handle)
StuffTop.Name = "StuffTop"
StuffTop.MeshId = "10469363693"

Vitamins.Activated:Connect(function()
    Character.Humanoid:LoadAnimation(UseAnimation):Play()
    SoundEffect:Play()

    local currentBoost = Character:GetAttribute("SpeedBoost") or 0
    Character:SetAttribute("SpeedBoost", currentBoost + 5)
task.wait(0.3)
Vitamins:Destroy()
    task.spawn(function()
        task.wait(5)
                local remainingBoost = Character:GetAttribute("SpeedBoost") or 0
        Character:SetAttribute("SpeedBoost", math.max(remainingBoost - 5, 0))
    end)
end)
	end
})
MiscBox:AddButton({
	Text    = "Infinite Vitamins",
	DoubleClick = true,
	Func = function()
		Character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
Backpack = game.Players.LocalPlayer.Backpack

Vitamins = Instance.new("Tool", Backpack)
Vitamins.Name = "Vitamins"
Vitamins.TextureId = "rbxassetid://10482863785"

Handle = Instance.new("MeshPart", Vitamins)
Handle.Name = "Handle"
Handle.MeshId = "rbxassetid://10469363179"
Handle.Size = Vector3.new(0.02, 0.02, 0.02)

SoundEffect = Instance.new("Sound", Handle)
SoundEffect.SoundId = "rbxassetid://11405639640"

UseAnimation = Instance.new("Animation", Vitamins)
UseAnimation.AnimationId = "rbxassetid://10482563149"

Label = Instance.new("MeshPart", Handle)
Label.Name = "Label"
Label.MeshId = "rbxassetid://10469363500"

Lid = Instance.new("MeshPart", Handle)
Lid.Name = "Lid"
Lid.MeshId = "rbxassetid://10469363357"

Stuff = Instance.new("MeshPart", Handle)
Stuff.Name = "Stuff"
Stuff.MeshId = "rbxassetid://10469363693"

StuffTop = Instance.new("MeshPart", Handle)
StuffTop.Name = "StuffTop"
StuffTop.MeshId = "10469363693"

Vitamins.Activated:Connect(function()
    Character.Humanoid:LoadAnimation(UseAnimation):Play()
    SoundEffect:Play()

    local currentBoost = Character:GetAttribute("SpeedBoost") or 0
    Character:SetAttribute("SpeedBoost", currentBoost + 5)

    task.spawn(function()
        task.wait(5)
        local remainingBoost = Character:GetAttribute("SpeedBoost") or 0
        Character:SetAttribute("SpeedBoost", math.max(remainingBoost - 5, 0))
    end)
end)
	end
})
MiscBox:AddButton({
	Text    = "Starlight Jug",
	DoubleClick = true,
	Func = function()
		local TweenService = game:GetService("TweenService")
local StarJug = game:GetObjects("rbxassetid://119885581324516")[1]

local speedTweenValue = Instance.new("NumberValue", StarJug)

local durability = 4
local debounce = false
StarJug:SetAttribute("Durability", durability)

StarJug.Parent = game.Players.LocalPlayer.Backpack

local character = game.Players.LocalPlayer.Character
local humanoid = character:FindFirstChildOfClass("Humanoid")

local Animations = StarJug:WaitForChild("Animations")
local LoadedAnims = {}

for _, anim in pairs(Animations:GetChildren()) do
    LoadedAnims[anim.Name] = humanoid:LoadAnimation(anim)

    if anim.Name == "idle" then
        LoadedAnims[anim.Name].Priority = Enum.AnimationPriority.Idle
        LoadedAnims[anim.Name].Looped = true
    end
end

StarJug.Equipped:Connect(function()
    LoadedAnims["equip"]:Play()

    task.wait(LoadedAnims["equip"].Length)

    if StarJug:IsDescendantOf(character) then
        LoadedAnims["idle"]:Play()
    end
end)

StarJug.Unequipped:Connect(function()
    if LoadedAnims["idle"].IsPlaying then
        LoadedAnims["idle"]:Stop()
    end
end)

local collisionClone
StarJug.Activated:Connect(function()
    if debounce then return end
    debounce = true

    LoadedAnims["open"]:Play()

    if durability - 1 ~= 0 then
        durability = durability - 1
        StarJug:SetAttribute("Durability", durability)
    else
        StarJug:Destroy()
    end

    character:SetAttribute("Starlight", true)
    character:SetAttribute("StarlightHuge", true)

    local speedBoost, speedBoostFinished, mspaint_speed = 30, false, false
    if getgenv().mspaint_loaded then
        if collisionClone then collisionClone:Destroy() end
        mspaint_speed = true

        local originalSpeed = getgenv().Linoria.Toggles.SpeedBypass.Value
        repeat task.wait()
            if not getgenv().Linoria.Toggles.SpeedBypass.Value then
                getgenv().Linoria.Toggles.SpeedBypass:SetValue(true)
            end
        until speedBoostFinished
        getgenv().Linoria.Toggles.SpeedBypass:SetValue(originalSpeed)
    else
        if not collisionClone then
            
            end
        

        task.spawn(function()
            while not speedBoostFinished do
                collisionClone.Massless = not collisionClone.Massless
                task.wait(0.21)
            end

            collisionClone.Massless = true
        end)
    end

    speedTweenValue.Value = 35
    TweenService:Create(speedTweenValue, TweenInfo.new(70, Enum.EasingStyle.Linear), {
        Value = 0
    }):Play()

    local conn; conn = speedTweenValue:GetPropertyChangedSignal("Value"):Connect(function()
        character:SetAttribute("SpeedBoost", speedTweenValue.Value)
    end)

    task.wait(35)

    speedBoostFinished = true
    conn:Disconnect()
    

    character:SetAttribute("Starlight", false)
    character:SetAttribute("StarlightHuge", false)
    character:SetAttribute("SpeedBoost", 0)
    debounce = false
end)
end
})
MiscBox:AddButton({
	Text    = "Infinite Jug of StarLight",
	DoubleClick = true,
	Func = function()
		local TweenService = game:GetService("TweenService")
local StarJug = game:GetObjects("rbxassetid://119885581324516")[1]

local speedTweenValue = Instance.new("NumberValue", StarJug)

local durability = 4
local debounce = false
StarJug:SetAttribute("Durability", durability)

StarJug.Parent = game.Players.LocalPlayer.Backpack

local character = game.Players.LocalPlayer.Character
local humanoid = character:FindFirstChildOfClass("Humanoid")

local Animations = StarJug:WaitForChild("Animations")
local LoadedAnims = {}

for _, anim in pairs(Animations:GetChildren()) do
    LoadedAnims[anim.Name] = humanoid:LoadAnimation(anim)

    if anim.Name == "idle" then
        LoadedAnims[anim.Name].Priority = Enum.AnimationPriority.Idle
        LoadedAnims[anim.Name].Looped = true
    end
end

StarJug.Equipped:Connect(function()
    LoadedAnims["equip"]:Play()

    task.wait(LoadedAnims["equip"].Length)

    if StarJug:IsDescendantOf(character) then
        LoadedAnims["idle"]:Play()
    end
end)

StarJug.Unequipped:Connect(function()
    if LoadedAnims["idle"].IsPlaying then
        LoadedAnims["idle"]:Stop()
    end
end)

local collisionClone
StarJug.Activated:Connect(function()
    if debounce then return end
    debounce = true

    LoadedAnims["open"]:Play()

    if durability - 1 ~= 0 then
        durability = durability 
        StarJug:SetAttribute("Durability", durability)
    else
        StarJug:Destroy()
    end

    character:SetAttribute("Starlight", true)
    character:SetAttribute("StarlightHuge", true)

    local speedBoost, speedBoostFinished, mspaint_speed = 30, false, false
    if getgenv().mspaint_loaded then
        if collisionClone then collisionClone:Destroy() end
        mspaint_speed = true

        local originalSpeed = getgenv().Linoria.Toggles.SpeedBypass.Value
        repeat task.wait()
            if not getgenv().Linoria.Toggles.SpeedBypass.Value then
                getgenv().Linoria.Toggles.SpeedBypass:SetValue(true)
            end
        until speedBoostFinished
        getgenv().Linoria.Toggles.SpeedBypass:SetValue(originalSpeed)
    else
        if not collisionClone then
            collisionClone = character.Collision:Clone() do
                collisionClone.CanCollide = false
                collisionClone.Massless = true
                collisionClone.Name = "CollisionClone"
                if collisionClone:FindFirstChild("CollisionCrouch") then
                    collisionClone.CollisionCrouch:Destroy()
                end

                collisionClone.Parent = character    
            end
        end

        task.spawn(function()
            while not speedBoostFinished do
                collisionClone.Massless = not collisionClone.Massless
                task.wait(0.21)
            end

            collisionClone.Massless = true
        end)
    end

    speedTweenValue.Value = 35
    TweenService:Create(speedTweenValue, TweenInfo.new(70, Enum.EasingStyle.Linear), {
        Value = 0
    }):Play()

    local conn; conn = speedTweenValue:GetPropertyChangedSignal("Value"):Connect(function()
        character:SetAttribute("SpeedBoost", speedTweenValue.Value)
    end)

    task.wait(35)

    speedBoostFinished = true
    conn:Disconnect()
    

    character:SetAttribute("Starlight", false)
    character:SetAttribute("StarlightHuge", false)
    character:SetAttribute("SpeedBoost", 0)
    debounce = false
end)
	end
})
ESPBox:AddToggle("Ladder ESP", {
    Text    = "Ladder ESP",
    Default = false,
    Callback = function(enabled)
        if enabled then
            LadderESPList = {}  -- table of all ESP’d ladder Instances
            LadderESPConnection = workspace.CurrentRooms.DescendantAdded:Connect(function(desc)
                if desc.Name == "Ladder" then
                    ESPLibrary:AddESP({ Object = desc, Text = "Ladder", Color = Color3.fromRGB(0, 0, 255)})
                    table.insert(LadderESPList, desc)
                end
            end)  -- 0

            for i, obj in ipairs(workspace.CurrentRooms:GetDescendants()) do
                if obj.Name == "Ladder" then
                    ESPLibrary:AddESP({ Object = obj, Text = "Ladder", Color = Color3.fromRGB(0, 0, 255) })
                    table.insert(LadderESPList, obj)
                end
            end  -- 1

        else
            if LadderESPConnection then
                LadderESPConnection:Disconnect()
                LadderESPConnection = nil
            end

            for _, obj in ipairs(LadderESPList) do
                ESPLibrary:RemoveESP(obj)
            end

            LadderESPList = nil
        end
    end
})
local RunService = game:GetService("RunService")
local Character  = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()

-- Cache the connection so we can disconnect on untoggle
local ladderBypassConn

local AntiCheatToggle = BypassBox:AddToggle("AntiCheat Bypass (Ladder Method)", {
    Text    = "AntiCheat Bypass (Ladder Method)",
    Default = false,
})
AntiCheatToggle:OnChanged(function(enabled)
    -- if turning off, disconnect
    if not enabled then
        if ladderBypassConn then
            ladderBypassConn:Disconnect()
            ladderBypassConn = nil
        end
        return
    end

    -- on toggle on, hook Heartbeat and clear the Climbing attribute each frame
    ladderBypassConn = RunService.Heartbeat:Connect(function()
        Character:SetAttribute("Climbing", false)
    end)
end)
-- 6) Toggle registration
-- Services & GUI refs


-- Control flags
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players           = game:GetService("Players")
local Workspace         = game:GetService("Workspace")

-- GameData & Rooms
local GameData       = ReplicatedStorage:WaitForChild("GameData")
local LatestRoomVal  = GameData:WaitForChild("LatestRoom")
local CurrentRooms   = Workspace:WaitForChild("CurrentRooms")

-- Player shortcuts
local LocalPlayer    = Players.LocalPlayer
local character      = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local hrp            = character:WaitForChild("HumanoidRootPart")
local PlayerGui      = LocalPlayer:WaitForChild("PlayerGui")

-- Find your breaker-style remote once
local BreakerRemote
do
    local descs = ReplicatedStorage:GetDescendants()
    for i = 1, #descs do
        if descs[i].Name == "AnchorRemote" then
            BreakerRemote = descs[i]
            break
        end
    end
end

-- Shift helper (unchanged RTL logic)
local function shiftCodeRTL(code, op, n)
    local len, out = #code, {}
    for rev = 1, len do
        local i = len - rev + 1
        local ch = code:sub(i, i)
        local d = tonumber(ch)
        if d then
            if op == "+" then
                d = (d + n) % 10
            else
                d = (d - n) % 10
                if d < 0 then d += 10 end
            end
            out[i] = tostring(d)
        else
            out[i] = ch
        end
    end
    return table.concat(out)
end

-- Toggle state
local runSolver = false

AutoBox:AddToggle("Auto Anchor Solver", {
    Text    = "Auto Anchor Solver",
    Default = false,
    Callback = function(enabled)
    local CodeLabel      = PlayerGui.MainUI:WaitForChild("AnchorHintFrame"):WaitForChild("Code")

        runSolver = enabled
        if not BreakerRemote then
            warn("AnchorRemote not found!")
            return
        end
        if enabled then
            task.spawn(function()
                while runSolver do
                    task.wait(0.1)

                    -- ensure we're in the Mines room (50)
                    local roomName = tostring(LatestRoomVal.Value)
                    if roomName ~= "50" then
                        -- wait until it is
                        repeat task.wait(0.2) until tostring(LatestRoomVal.Value) == "50" or not runSolver
                        if not runSolver then break end
                    end

                    local room = CurrentRooms:FindFirstChild("50")
                    if not room then continue end

                    -- read the on-screen code each iteration
                    local baseCode = CodeLabel.Text or ""
                    local finalCode = baseCode

                    -- scan for the visible MinesAnchor
                    local desc = room:GetDescendants()
                    for i = 1, #desc do
                        local inst = desc[i]
                        if inst.Name == "MinesAnchor"
                        and inst:FindFirstChild("GuideHighlight")
                        and inst.GuideHighlight.FillTransparency < 1
                        then
                            -- check distance (30 studs)
                            local part = inst.PrimaryPart or inst:FindFirstChildWhichIsA("BasePart")
                            if not part then break end
                            if (hrp.Position - part.Position).Magnitude > 30 then
                                continue 
                            end

                            -- parse the note for op/val
                            local note = inst:FindFirstChild("Note")
                            if note then
                                local gui   = note:FindFirstChild("SurfaceGui")
                                local label = gui and gui:FindFirstChild("TextLabel")
                                if label then
                                    local op  = label.Text:sub(1,1)
                                    local val = tonumber(label.Text:sub(2))
                                    if (op == "+" or op == "-") and val then
                                        finalCode = shiftCodeRTL(baseCode, op, val)
                                    end
                                end
                            end

                            -- invoke with unpack-style args
                            Library:Notify("Automatically  Solving Anchor, Code is" .. finalCode,2)
                            local args = { finalCode }
                            BreakerRemote:InvokeServer(unpack(args))
                            break
                        end
                    end
                end
            end)
        end
    end,
})

-- Services
Workspace = game:GetService("Workspace")
RunService = game:GetService("RunService")
TARGET_NAME = "SeekGuidingLight"

-- Mapping from targetPart to guide Part
seekLightGuides = {}       -- [targetPart] = guidePart
-- Mapping from targetPart to last known CFrame, to skip redundant updates
seekLastCFrames = {}       -- [targetPart] = CFrame

descAddConnection = nil
descRemConnection = nil
updateConnection = nil

function createGuideFor(targetPart)
    if seekLightGuides[targetPart] then
        return
    end
    -- Create anchored Part that will match target's CFrame exactly
    local guide = Instance.new("Part")
    guide.Name = "SeekLightGuide"
    guide.Size = Vector3.new(1, 1, 1)
    guide.Anchored = true            -- no physics overhead
    guide.CanCollide = false
    guide.Material = Enum.Material.Neon
    guide.BrickColor = BrickColor.new("Bright yellow")
    guide.Transparency = 0.5
    guide.CFrame = targetPart.CFrame -- initial match
    guide.Parent = Workspace

    seekLightGuides[targetPart] = guide
    seekLastCFrames[targetPart] = targetPart.CFrame

    -- Ensure the update loop is running
    if not updateConnection then
        updateConnection = RunService.RenderStepped:Connect(function()
            -- Iterate through all guides
            for target, guidePart in pairs(seekLightGuides) do
                -- If target no longer exists under Workspace, remove guide
                if not target:IsDescendantOf(Workspace) then
                    guidePart:Destroy()
                    seekLightGuides[target] = nil
                    seekLastCFrames[target] = nil
                else
                    local currentCF = target.CFrame
                    -- Only update if changed since last frame
                    if currentCF ~= seekLastCFrames[target] then
                        guidePart.CFrame = currentCF
                        seekLastCFrames[target] = currentCF
                    end
                end
            end
            -- If no guides remain, disconnect loop to avoid overhead
            if next(seekLightGuides) == nil then
                updateConnection:Disconnect()
                updateConnection = nil
            end
        end)
    end
end

function removeGuideFor(targetPart)
    local guide = seekLightGuides[targetPart]
    if guide then
        guide:Destroy()
        seekLightGuides[targetPart] = nil
        seekLastCFrames[targetPart] = nil
    end
end

function onDescendantAdded(desc)
    if desc:IsA("BasePart") and desc.Name == TARGET_NAME then
        createGuideFor(desc)
    end
end

function onDescendantRemoving(desc)
    if desc:IsA("BasePart") and desc.Name == TARGET_NAME then
        removeGuideFor(desc)
    end
end

function scanWorkspaceBFS()
    -- Breadth-first traversal with chunked yields to avoid frame spike
    local queue = {Workspace}
    local head = 1
    local processed = 0
    local MAX_PER_FRAME = 50
    while head <= #queue do
        local node = queue[head]
        head = head + 1
        for _, child in ipairs(node:GetChildren()) do
            if child:IsA("BasePart") and child.Name == TARGET_NAME then
                createGuideFor(child)
            end
            queue[#queue + 1] = child
        end
        processed = processed + 1
        if processed >= MAX_PER_FRAME then
            processed = 0
            task.wait()
        end
    end
end

function enableSeekGuides()
    -- Disconnect existing connections
    if descAddConnection then
        descAddConnection:Disconnect()
        descAddConnection = nil
    end
    if descRemConnection then
        descRemConnection:Disconnect()
        descRemConnection = nil
    end
    -- Destroy any existing guides
    for target, _ in pairs(seekLightGuides) do
        removeGuideFor(target)
    end
    seekLightGuides = {}
    seekLastCFrames = {}

    -- Connect events
    descAddConnection = Workspace.DescendantAdded:Connect(onDescendantAdded)
    descRemConnection = Workspace.DescendantRemoving:Connect(onDescendantRemoving)
    -- Start BFS scan in separate thread
    task.spawn(scanWorkspaceBFS)
end

function disableSeekGuides()
    if descAddConnection then
        descAddConnection:Disconnect()
        descAddConnection = nil
    end
    if descRemConnection then
        descRemConnection:Disconnect()
        descRemConnection = nil
    end
    if updateConnection then
        updateConnection:Disconnect()
        updateConnection = nil
    end
    -- Destroy all guides
    for target, _ in pairs(seekLightGuides) do
        removeGuideFor(target)
    end
    seekLightGuides = {}
    seekLastCFrames = {}
end

-- Integrate with UI toggle (no extra `})` after)
MinesBox:AddToggle("ShowSeekGuides", {
    Text    = "Show PathfindingNodes (Seek)",
    Default = false,
    Callback = function(enabled)
        if enabled then
            enableSeekGuides()
        else
            disableSeekGuides()
        end
    end
})
-- BEFORE using PlayerBox:AddToggle, define the Fly logic globally (or

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer

-- Fly table (global so PlayerBox callbacks and console can access it)
Fly = Fly or {}
Fly.Enabled = false
 Fly.Speed = 15
Fly.FlyBody = nil
Fly.FlyGyro = nil

-- Connections (to be created/destroyed when flying toggles)
local renderConn = nil
local charAddedConn = nil

-- Setup BodyVelocity & BodyGyro on HumanoidRootPart
function Fly.SetupBodies(char)
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return end

    -- BodyVelocity: maintain target velocity
    local bv = Instance.new("BodyVelocity")
    bv.Name = "FlyBodyVelocity"
    bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)   -- high force to override gravity/forces 6
    bv.Velocity = Vector3.zero
    bv.Parent = root
    Fly.FlyBody = bv

    -- BodyGyro: maintain orientation matching camera
    local bg = Instance.new("BodyGyro")
    bg.Name = "FlyBodyGyro"
    bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)   -- high torque 7
    local cam = workspace.CurrentCamera
    if cam then
        bg.CFrame = cam.CFrame
    end
    bg.Parent = root
    Fly.FlyGyro = bg

    -- Disable default physics on the humanoid
    local humanoid = char:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.PlatformStand = true
    end
end

-- Cleanup bodies on disable
function Fly.CleanupBodies()
    if Fly.FlyBody then
        Fly.FlyBody:Destroy()
        Fly.FlyBody = nil
    end
    if Fly.FlyGyro then
        Fly.FlyGyro:Destroy()
        Fly.FlyGyro = nil
    end

    -- Restore default physics
    local char = player.Character
    if char then
        local humanoid = char:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.PlatformStand = false
        end
    end
end

-- Per-frame update while flying: apply camera-tilt-based movement
local function onRenderStepped()
    if not Fly.Enabled then return end

    local char = player.Character
    if not char then return end

    local humanoid = char:FindFirstChild("Humanoid")
    local root = char:FindFirstChild("HumanoidRootPart")
    local cam = workspace.CurrentCamera
    if not humanoid or not root or not Fly.FlyBody or not Fly.FlyGyro or not cam then
        return
    end

    local dir = Vector3.zero

    if UserInputService.KeyboardEnabled then
        -- Desktop: WASD keys
        local forward = UserInputService:IsKeyDown(Enum.KeyCode.W)
        local back    = UserInputService:IsKeyDown(Enum.KeyCode.S)
        local left    = UserInputService:IsKeyDown(Enum.KeyCode.A)
        local right   = UserInputService:IsKeyDown(Enum.KeyCode.D)

        local camCFrame = cam.CFrame
        local lookVec = camCFrame.LookVector
        local rightVec = camCFrame.RightVector

        if forward then
            dir = dir + lookVec
        end
        if back then
            dir = dir - lookVec
        end
        if left then
            dir = dir - rightVec
        end
        if right then
            dir = dir + rightVec
        end
    else
        -- Mobile: use humanoid.MoveDirection for horizontal input (Y=0) 8
        local moveDir = humanoid.MoveDirection
        if moveDir.Magnitude > 0 then
            local camCFrame = cam.CFrame
            local flatLook = Vector3.new(camCFrame.LookVector.X, 0, camCFrame.LookVector.Z)
            local flatRight = Vector3.new(camCFrame.RightVector.X, 0, camCFrame.RightVector.Z)
            if flatLook.Magnitude > 0 then
                flatLook = flatLook.Unit
            end
            if flatRight.Magnitude > 0 then
                flatRight = flatRight.Unit
            end

            local forwardWeight = moveDir:Dot(flatLook)
            local rightWeight = moveDir:Dot(flatRight)
            -- Combine full camera vectors (including Y) for vertical component
            dir = camCFrame.LookVector * forwardWeight + camCFrame.RightVector * rightWeight
        end
    end

    -- Apply velocity: if input present, move along dir at Fly.Speed; else hover
    if dir.Magnitude > 0 then
        Fly.FlyBody.Velocity = dir.Unit * Fly.Speed
    else
        Fly.FlyBody.Velocity = Vector3.zero
    end

    -- Match orientation to camera for consistent movement direction
    Fly.FlyGyro.CFrame = cam.CFrame

    -- Keep humanoid in PlatformStand
    humanoid.PlatformStand = true
end

-- Enable flying
function Fly.Enable()
    if Fly.Enabled then return end
    Fly.Enabled = true

    -- Setup bodies if character exists
    local char = player.Character
    if char then
        Fly.SetupBodies(char)
    end

    -- Connect RenderStepped if not already
    if not renderConn then
        renderConn = RunService.RenderStepped:Connect(onRenderStepped)
    end

    -- Connect CharacterAdded to reapply on respawn
    if not charAddedConn then
        charAddedConn = player.CharacterAdded:Connect(function(char2)
            if Fly.Enabled then
                char2:WaitForChild("HumanoidRootPart")
                Fly.SetupBodies(char2)
            end
        end)
    end
end

-- Disable flying
function Fly.Disable()
    if not Fly.Enabled then return end
    Fly.Enabled = false

    -- Cleanup bodies
    Fly.CleanupBodies()

    -- Disconnect RenderStepped
    if renderConn then
        renderConn:Disconnect()
        renderConn = nil
    end

    -- Disconnect CharacterAdded
    if charAddedConn then
        charAddedConn:Disconnect()
        charAddedConn = nil
    end
end

-- Toggle flying
function Fly.Toggle()
    if Fly.Enabled then
        Fly.Disable()
    else
        Fly.Enable()
    end
end

-- Adjust speed
function Fly.SetSpeed(newSpeed)
    Fly.Speed = newSpeed or Fly.Speed
end

-- PlayerBox slider integration for Fly.Speed
FlySpeed = PlayerBox:AddSlider("FlySpeed", {
    Text = "Fly Speed",
    Min = 10,
    Max = 100,
    Default = Fly.Speed,
    Rounding = 0,
    Callback = function(v)
        Fly.SetSpeed(v)
    end
})

-- PlayerBox toggle integration
PlayerBox:AddToggle("Fly", {
    Text = "Fly",
    Default = false,
    Callback = function(enabled)
        if enabled then
            Fly.Enable()
        else
            Fly.Disable()
        end
    end
}):AddKeyPicker('Fly Keybind', {


            Default = 'F', -- String as the name of the keybind (MB1, MB2 for mouse buttons)
            SyncToggleState = true,


            -- You can define custom Modes but I have never had a use for it.
            Mode = 'Toggle', -- Modes: Always, Toggle, Hold

            Text = 'Fly', -- Text to display in the keybind menu
            NoUI = false, -- Set to true if you want to hide from the Keybind menu,

            -- Occurs when the keybind is clicked, Value is `true`/`false`
            Callback = function(Value)



            end,

            -- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
            ChangedCallback = function(New)
            end
        })
        -- Third-Person Camera with Head Hide/Show Integration in one script

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer

-- Offsets (initialized)
local offsetX = 0
local offsetY = 0   -- e.g., slightly above head center
local offsetZ = 4   -- behind the head

-- Connections and state
local transparencyConnections = {}
local renderConn = nil
local charAddedConn = nil
local toggleState = false

-- Utility: lock LocalTransparencyModifier on head & accessories to a given value (0 = visible, 1 = fully invisible locally)
local function lockTransparency(char, value)
    -- First disconnect any existing locks
    for _, conn in ipairs(transparencyConnections) do
        conn:Disconnect()
    end
    transparencyConnections = {}

    -- Iterate over children
    for _, v in ipairs(char:GetChildren()) do
        if v:IsA("Accessory") and v:FindFirstChild("Handle") then
            local handle = v.Handle
            -- Set immediately
            handle.LocalTransparencyModifier = value  -- 0
            -- Lock it
            transparencyConnections[#transparencyConnections+1] = handle:GetPropertyChangedSignal("LocalTransparencyModifier"):Connect(function()
                handle.LocalTransparencyModifier = value
            end)
        end
        if v.Name == "Head" and v:IsA("BasePart") then
            local head = v
            head.LocalTransparencyModifier = value  -- 1
            transparencyConnections[#transparencyConnections+1] = head:GetPropertyChangedSignal("LocalTransparencyModifier"):Connect(function()
                head.LocalTransparencyModifier = value
            end)
        end
    end
end

-- Camera update: set CFrame relative to head plus offsets
local function updateCameraThirdPerson()
    local char = player.Character
    if not char then return end
    local head = char:FindFirstChild("Head")
    if not head then return end

    local cam = Workspace.CurrentCamera
    if not cam then return end

    -- Override CameraType to Scriptable so default camera logic doesn't override
    cam.CameraType = Enum.CameraType.Scriptable

    -- Compute new CFrame: head.CFrame * offset
    local baseCFrame = head.CFrame
    local offsetCFrame = CFrame.new(offsetX, offsetY, offsetZ)
    cam.CFrame = baseCFrame * offsetCFrame  -- 2
end

-- Enable third-person: show head, lock transparency=0, connect camera update & respawn handling
local function enableThirdPerson()
    if toggleState then return end
    toggleState = true

    local char = player.Character
    if char then
        -- Show head & accessories
        lockTransparency(char, 0)
    end

    -- Connect RenderStepped
    if not renderConn then
        renderConn = RunService.RenderStepped:Connect(updateCameraThirdPerson)  -- 3
    end

    -- Respawn handling: re-lock transparency=0 and continue camera update after respawn
    if not charAddedConn then
        charAddedConn = player.CharacterAdded:Connect(function(newChar)
            -- Wait for head
            local head = newChar:WaitForChild("Head", 5)
            if head then
                lockTransparency(newChar, 0)
            end
        end)
    end
end

-- Disable third-person: hide head, lock transparency=1, disconnect camera update & restore default camera
local function disableThirdPerson()
    if not toggleState then return end
    toggleState = false

    -- Disconnect RenderStepped
    if renderConn then
        renderConn:Disconnect()
        renderConn = nil
    end
    -- Disconnect respawn handler
    if charAddedConn then
        charAddedConn:Disconnect()
        charAddedConn = nil
    end

    -- Hide head & accessories
    local char = player.Character
    if char then
        lockTransparency(char, 1)
    end

    -- Restore default camera behavior
    local cam = Workspace.CurrentCamera
    if cam then
        cam.CameraType = Enum.CameraType.Custom  -- 4
        -- Reset CameraSubject to Humanoid so first-person/follow works normally
        if player.Character then
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid then
                cam.CameraSubject = humanoid  -- 5
            end
        end
    end
end

-- Slider integration
PlayerBox:AddSlider("ThirdPersonX", {
    Text = "Third Person X",
    Min = -10,
    Max = 10,
    Default = offsetX,
    Rounding = 0,
    Callback = function(v)
        offsetX = v
        if toggleState then
            updateCameraThirdPerson()
        end
    end
})

PlayerBox:AddSlider("ThirdPersonY", {
    Text = "Third Person Y",
    Min = -10,
    Max = 10,
    Default = offsetY,
    Rounding = 0,
    Callback = function(v)
        offsetY = v
        if toggleState then
            updateCameraThirdPerson()
        end
    end
})

PlayerBox:AddSlider("ThirdPersonZ", {
    Text = "Third Person Z",
    Min = -10,
    Max = 10,
    Default = offsetZ,
    Rounding = 0,
    Callback = function(v)
        offsetZ = v
        if toggleState then
            updateCameraThirdPerson()
        end
    end
})

-- Toggle integration
PlayerBox:AddToggle("ThirdPerson", {
    Text = "Third Person",
    Default = false,
    Callback = function(enabled)
        if enabled then
            enableThirdPerson()
        else
            disableThirdPerson()
        end
    end
}):AddKeyPicker('ThirdP Keybind', {


            Default = 'T', -- String as the name of the keybind (MB1, MB2 for mouse buttons)
            SyncToggleState = true,


            -- You can define custom Modes but I have never had a use for it.
            Mode = 'Toggle', -- Modes: Always, Toggle, Hold

            Text = 'ThirdPerson', -- Text to display in the keybind menu
            NoUI = false, -- Set to true if you want to hide from the Keybind menu,

            -- Occurs when the keybind is clicked, Value is `true`/`false`
            Callback = function(Value)



            end,

            -- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
            ChangedCallback = function(New)
            end
        })

-- On initial load: ensure head is hidden so it won't block FOV in first-person by default
-- e.g., if player spawns before toggling, hide head LocalTransparencyModifier
-- (optional: comment out if you prefer head visible until toggled)
if player.Character then
    lockTransparency(player.Character, 1)
end
-- Also handle respawn to keep head hidden by default
player.CharacterAdded:Connect(function(newChar)
    newChar:WaitForChild("Head", 5)
    if not toggleState then
        lockTransparency(newChar, 1)
    else
        lockTransparency(newChar, 0)
    end
end)
RunService      = game:GetService("RunService")
ReplicatedDS    = game:GetService("ReplicatedStorage").GameData

local doorReachConn
throttleTimer     = 0
THROTTLE_INTERVAL = 0.05

-- create the toggle and grab its handle
local DoorReach = PlayerBox:AddToggle("DoorReach", {
	Text    = "Door Reach",
	Tooltip = "Makes Door Open From Far"
})

DoorReach:OnChanged(function(enabled)
	-- cleanup any previous connection
	if doorReachConn then
		doorReachConn:Disconnect()
		doorReachConn = nil
		throttleTimer = 0
	end

	if not enabled then
		return
	end

	-- start a new Heartbeat connection
	doorReachConn = RunService.Heartbeat:Connect(function(dt)
		throttleTimer = throttleTimer + dt
		if throttleTimer < THROTTLE_INTERVAL then
			return
		end
		throttleTimer = throttleTimer - THROTTLE_INTERVAL

		-- look up the current room by name
		local roomName = ReplicatedDS.LatestRoom.Value
		local room     = CurrentRooms:FindFirstChild(roomName)
		if not room then
			return
		end

		-- if the door exists and has the ClientOpen remote, fire it
		 door = room:FindFirstChild("Door")
		if door and door:FindFirstChild("ClientOpen") then
			door.ClientOpen:FireServer()
		end
	end)
end)

 

























































 local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"


Library =  loadstring(game:HttpGet(repo..'Library.lua'))()
Library:Notify("Loading Prohax .. ",3)
ThemeManager = loadstring(game:HttpGet(repo..'addons/ThemeManager.lua'))()
SaveManager  = loadstring(game:HttpGet(repo..'addons/SaveManager.lua'))()
Options = Library.Options
Toggles = Library.Toggles

 
ESPLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/bocaj111004/ESPLibrary/refs/heads/main/main.lua"))() 
ESPLibrary:SetFadeTime(0.5)
Window = Library:CreateWindow({Title='ProHax V3',Center=true,AutoShow=true})
Tabs = {
	Player     = Window:AddTab('Main'),
	Anti       = Window:AddTab('Exploits'),
	Auto       = Window:AddTab('Visuals'),
	Floors     = Window:AddTab('Floors'),
Misc = Window:AddTab('Miscellaneous'),
	Fun = Window:AddTab('Trolling'),    UISettings = Window:AddTab('UI Settings'),
}
PlayerBox = Tabs.Player:AddLeftGroupbox('LocalPlayer')
AntiBox   = Tabs.Anti:AddLeftGroupbox('Bypass Entities')
AutoBox   = Tabs.Player:AddRightGroupbox('Automatically')
ESPBox    = Tabs.Auto:AddLeftGroupbox('ESP')
ESPSettings    = Tabs.Auto:AddRightGroupbox('Visuals')
BypassBox = Tabs.Anti:AddRightGroupbox('Bypass')
FloorsBox = Tabs.Floors:AddRightGroupbox('Floors Bypass Entities')
FloorsBx = Tabs.Floors:AddLeftGroupbox('Main Floor')
SettingsBox = Tabs.UISettings:AddLeftGroupbox('Themes & Keybinds')
MiscBox = Tabs.Misc:AddRightGroupbox('Remotes')
MiscBox2 = Tabs.Misc:AddRightGroupbox('Reach')
MiscBox3 = Tabs.Misc:AddLeftGroupbox('Disable')

TrollBox = Tabs.Fun:AddLeftGroupbox('Troll')
-- Services & References
Players           = game:GetService("Players")
PathfindingService = game:GetService("PathfindingService")
RunService        = game:GetService('RunService')
ReplicatedStorage = game:GetService('ReplicatedStorage')
Workspace         = game:GetService('Workspace')
StarterGui        = game:GetService('StarterGui')
Lighting          = game:GetService('Lighting')
LocalPlayer       = Players.LocalPlayer
Character         = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
Humanoid          = Character:WaitForChild('Humanoid')
HumanoidRootPart  = Character:WaitForChild('HumanoidRootPart')
CurrentRooms      = Workspace:WaitForChild('CurrentRooms')
GameData          = ReplicatedStorage:WaitForChild("GameData")
LocalPlayer = Players.LocalPlayer
Camera      = Workspace.CurrentCamera
LocalPlayer.Character.HumanoidRootPart.CanCollide = true
if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Collision") and LocalPlayer.Character.Collision:FindFirstChild("CollisionCrouch") then LocalPlayer.Character.Collision.CollisionCrouch:Destroy()
end
function ChatNotify(Text)
	local textchannel = game:GetService("TextChatService"):WaitForChild("TextChannels"):WaitForChild("RBXGeneral") 
	local message = Text
	textchannel:SendAsync(message)
end
pingid = "4590657391"
local function Sound()
	
		local sound = Instance.new("Sound")
		sound.Name = ESPLibrary:GenerateRandomString()
		sound.Volume = 1.4
		sound.Parent = game.ReplicatedStorage 

		sound.SoundId = "rbxassetid://"..pingid

		sound:Play()

		game:GetService("Debris"):AddItem(sound,15)
	
end
Sound()
 Library.NotifySide = "Right"

RunService       = game:GetService("RunService")
ReplicatedDS     = game:GetService("ReplicatedStorage").GameData
doorVelTable     = {}
cachedDoorParts  = {}
local heartConn, roomConn
INTERVAL         = 0.07
BreakDoorsFE = TrollBox:AddToggle("BreakDoorusFE", {
	Text = "Breaks Doors(FE)",
	Tooltip = "Bugs the Game Out"
})
function cleanAll()
	if heartConn then heartConn:Disconnect() heartConn = nil end
	if roomConn then roomConn:Disconnect() roomConn = nil end
	for part, data in pairs(doorVelTable) do
		if data.bv and data.bv.Parent then data.bv:Destroy() end
		if part and part.Parent then part.CanCollide = data.origCollide end
	end
	table.clear(doorVelTable)
	table.clear(cachedDoorParts)
end
function cacheDoorParts()
	table.clear(cachedDoorParts)
	local rooms = workspace.CurrentRooms:GetChildren()
	for i = 1, #rooms do
		local room = rooms[i]
		local children = room:GetChildren()
		for j = 1, #children do
			local obj = children[j]
			if obj:IsA("Model") then
				local descendants = obj:GetDescendants()
				for d = 1, #descendants do
					local descendant = descendants[d]
					if descendant:IsA("BasePart") then
						table.insert(cachedDoorParts, descendant)
					end
				end
			end
		end
	end
end
BreakDoorsFE:OnChanged(function(enabled)
	cleanAll()
	if not enabled then return end
	if not isnetworkowner then Library:Notify("[Break doors]) isnetworkowner is not supported it wont work",3) return end
	if tonumber(ReplicatedDS.LatestRoom.Value) >= 98 then BreakDoorsFE:SetValue(false) return end
	cacheDoorParts()
	roomConn = workspace.CurrentRooms.ChildAdded:Connect(function()
		cacheDoorParts()
	end)
	accumulator = 0
	heartConn = RunService.Heartbeat:Connect(function(dt)
		accumulator = accumulator + dt
		if accumulator < INTERVAL then return end
		accumulator = 0

		if tonumber(ReplicatedDS.LatestRoom.Value) >= 98 then
			BreakDoorsFE:SetValue(false)
			return
		end

		for i = 1, #cachedDoorParts do
			part = cachedDoorParts[i]
			if isnetworkowner(part) then
				if not doorVelTable[part] then
					local bv = Instance.new("BodyPosition")
					doorVelTable[part] = { origCollide = part.CanCollide, bv = bv }
					part.CanCollide = false
					bv.Name = "TeleportDoorsOnYou"
					bv.MaxForce = Vector3.new(1e9, 1e9,1e9)
					bv.Position = HumanoidRootPart.Position
					bv.Parent = part
				end
			elseif doorVelTable[part] then
				local data = doorVelTable[part]
				if data.bv and data.bv.Parent then data.bv:Destroy() end
				part.CanCollide = data.origCollide
				doorVelTable[part] = nil
			end
		end
	end)
end)
MiscBox3:AddLabel("Sounds", {
        Text = "Sounds is Extra Processing in  Device  Disabling them would improve fps on devices",
        DoesWrap = true, -- Defaults to false
})

local WalkingCon = nil
local WalkingValue = false
MiscBox3:AddToggle('DisableWalkingSound',{
	Text = "Disable Walking Sounds",
	Tooltip = "Removes the Sound that appears when you walk",
	Default = false,
	Callback = function(Value)
WalkingValue = Value
if WalkingCon then
WalkingCon:Disconnect()
WalkingCon = nil
end
if not WalkingValue then return end
WalkingCon = LocalPlayer.Character.ChildAdded:Connect(function(v)
if v:IsA("Sound") then v:Destroy()
end
end)
end
})
MiscBox3:AddToggle('DisableDrawersInteractionsSounds',{
	Text = "Disable Drawers Sounds",
	Tooltip = "Removes the Sound that appears at Drawers",
	Default = false,
	Callback = function(Value)

end
})
TrollBox:AddToggle('Stunned',{
	Text = "Stunned",
	Tooltip = "Makes People Think your Died",
	Default = false,
	Callback = function(Value)
		LocalPlayer.Character:SetAttribute("Stunned",Value)
	end
})
-- Services
-- Services
RunService = game:GetService("RunService")
Players = game:GetService("Players")

LocalPlayer = Players.LocalPlayer
Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
Humanoid = Character:WaitForChild("Humanoid")

oldspeed = Humanoid.WalkSpeed
lastspeed = 15

con = nil
st = false

SpeedSlider = PlayerBox:AddSlider('WalkSpeed', {
	Text = 'WalkSpeed',
	Min = 15, Max = 21.4, Default = 15,
	Rounding = 1,
	Callback = function(v)
		lastspeed = v
		if st and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
			LocalPlayer.Character.Humanoid.WalkSpeed = lastspeed
		end
	end
})
PlayerBox:AddDivider()
PlayerBox:AddToggle("EnableWalkSpeed", {
	Text = "Enable WalkSpeed",
	Default = false
})

Toggles.EnableWalkSpeed:OnChanged(function(value)
	st = value
	if con then
		con:Disconnect()
		con = nil
	end
	if not st then
		if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
			LocalPlayer.Character.Humanoid.WalkSpeed = oldspeed
		end
		return
	end
	if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
		LocalPlayer.Character.Humanoid.WalkSpeed = lastspeed
	end
	con = RunService.RenderStepped:Connect(function()
		if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
			LocalPlayer.Character.Humanoid.WalkSpeed = lastspeed
		end
	end)
end)
MiscBox:AddButton({
	Text    = "Reset",
	DoubleClick = true,

	Func = function()
	if replicatedsignal then	replicatedsignal(LocalPlayer.Kill)
end
end
})
MiscBox:AddButton({
	Text    = "Revive",
	DoubleClick = true,
	Func = function()
		if game.ReplicatedStorage:FindFirstChild("EntityInfo") then
			game.ReplicatedStorage.EntityInfo.Revive:FireServer()
		elseif ReplicatedStorage:FindFirstChild("RemotesFolder") then 

			game.ReplicatedStorage.RemotesFolder.Revive:FireServer()
else
game.ReplicatedStorage.Bricks.Revive:FireServer()
		end
	end
})
Players = game:GetService("Players")
RS      = game:GetService("ReplicatedStorage")

player      = Players.LocalPlayer
local playAgain   -- cached RemoteEvent
local charConn    -- Connection to CharacterAdded
local deathConn   -- Connection to humanoid.Died

-- Cache the PlayAgain remote
if RS:FindFirstChild("EntityInfo") then
	playAgain = RS.EntityInfo:WaitForChild("PlayAgain")
elseif RS:FindFirstChild("RemotesFolder") then
	playAgain = RS.RemotesFolder:WaitForChild("PlayAgain")
else
	playAgain = RS:FindFirstChild("Bricks"):WaitForChild("PlayAgain")
end

-- When a Humanoid dies, fire the cached event
function onHumanoidDied()
	if playAgain then
		playAgain:FireServer()
	end
end

-- Hook up death listener on each new Humanoid
function onCharacterAdded(character)
	-- Clean up previous death connection (if any)
	if deathConn then
		deathConn:Disconnect()
		deathConn = nil
	end
	-- Wait for the Humanoid and connect
	humanoid = character:WaitForChild("Humanoid")
	deathConn = humanoid.Died:Connect(onHumanoidDied)  
end

-- Toggle handler
AutoBox:AddToggle("AutoPlayAgain", {
	Text         = "Auto Play Again",
	Tooltip      = "Automatically enters a new game when you die",
	CurrentValue = false,
	Callback     = function(enabled)
		if enabled then
			-- Connect CharacterAdded once
			if not charConn then
				charConn = player.CharacterAdded:Connect(onCharacterAdded)
			end
			-- If already in-game, hook the current character
			if player.Character then
				onCharacterAdded(player.Character)
			end
		else
			-- Disconnect both listeners to clean up
			if deathConn then
				deathConn:Disconnect()
				deathConn = nil
			end
			if charConn then
				charConn:Disconnect()
				charConn = nil
			end
		end
	end,
})
 
MiscBox:AddButton({
	Text    = "PlayAgain",
	DoubleClick = true,
	Func = function()
		if game.ReplicatedStorage:FindFirstChild("EntityInfo") then
			game.ReplicatedStorage.EntityInfo.PlayAgain:FireServer()
		elseif ReplicatedStorage:FindFirstChild("RemotesFolder") then

			ReplicatedStorage.RemotesFolder.PlayAgain:FireServer()

else
ReplicatedStorage.Bricks.PlayAgain:FireServer()
		end
	end
})
MiscBox:AddButton({
	Text    = "Lobby",
	DoubleClick = true,
	Func = function()
		if game.ReplicatedStorage:FindFirstChild("EntityInfo") then
			game.ReplicatedStorage.EntityInfo.Lobby:FireServer()
		else
			game.ReplicatedStorage.RemotesFolder.Lobby:FireServer()
		end
	end
})
local RS = game:GetService("ReplicatedStorage")
if RS:FindFirstChild("Bricks") or RS:FindFirstChild("EntityInfo") then
local WS = game:GetService("Workspace")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local reviveToggle = false
local reviveCon

local function setupRevive(char)
	local hum = char:WaitForChild("Humanoid")
	if reviveCon then reviveCon:Disconnect() end

	reviveCon = hum.Died:Connect(function()
		local Info = RS:FindFirstChild("EntityInfo")
		local Bricks = RS:FindFirstChild("Bricks")
		if Info then
			Info.Revive:FireServer()
		elseif Bricks then
			Bricks:FireServer()
		end
		if reviveToggle then
			setupRevive(LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait())
		end
	end)
end

LocalPlayer.CharacterAdded:Connect(function(char)
	if reviveToggle then
		setupRevive(char)
	end
end)

FloorsBx:AddToggle("InfiniteRevive", {
	Text = "Infinite Revive",
	Default = false,
	Callback = function(state)
		reviveToggle = state
		if not state then
			if reviveCon then reviveCon:Disconnect() reviveCon = nil end
			return
		end
		if LocalPlayer.Character then
			setupRevive(LocalPlayer.Character)
		end
	end
})

	FloorsBx:AddToggle("FoolsGodmode", {
		Text = "God Mode",
		Default = false,
		Tooltip = "Make you Invincible To Entities",
		Callback = function(enabled)
			local char = LocalPlayer.Character
			if char and char:FindFirstChild("Collision") then
				local offset = Vector3.new(0, 9.5, 0)
				char.Collision.Position = enabled and (char.Collision.Position - offset) or (char.Collision.Position + offset)
			end
		end
	})

	FloorsBx:AddToggle("FigureGodmode", {
		Text = "Figure Godmode",
		Default = false,
		Tooltip = "Make you Immune to Figure",
		Callback = function(enabled)
			if enabled and not Toggles.FoolsGodmode.Value then
				Library:Notify("[Figure Godmode] Enabled God Mode automatically", 4)
				Toggles.FoolsGodmode:SetValue(true)
			end

			-- Loop to apply CanTouch repeatedly while enabled
			spawn(function()
				while Toggles.FigureGodmode.Value do
					local Figure = WS:FindFirstChild("FigureRagdoll", true)
					if Figure then
						for _, part in ipairs(Figure:GetChildren()) do
							if part:IsA("BasePart") then
								part.CanTouch = false
							end
						end
					end
					task.wait(1)
				end

				-- When disabled, reset CanTouch if Figure exists
				local Figure = WS:FindFirstChild("FigureRagdoll", true)
				if Figure then
					for _, part in ipairs(Figure:GetChildren()) do
						if part:IsA("BasePart") then
							part.CanTouch = true
						end
					end
				end
			end)
		end
	})
end
runSpam = false

TrollBox:AddToggle("SpamOthersTools", {
	Text = "Spam Others Tools (FE)",
	Default = false,
	Callback = function(state)
		runSpam = state
		if runSpam then
				while   task.wait(0.9) do
					
					if not runSpam then
						break
					end

					for _, plr in pairs(Players:GetPlayers()) do
if plr ~= LocalPlayer then
for _, tool in ipairs(plr:GetDescendants()) do
if tool:IsA("Tool") then
if tool:FindFirstChild("Remote") then
tool.Remote:FireServer()
end
end
end
end
end
end
end
end
}):AddKeyPicker('Spam Others Tools Keybind', {


	Default = 'X', -- String as the name of the keybind (MB1, MB2 for mouse buttons)
	SyncToggleState = true,


	-- You can define custom Modes but I have never had a use for it.
	Mode = 'Toggle', -- Modes: Always, Toggle, Hold

	Text = 'Spam Others Tools (FE)', -- Text to display in the keybind menu
	NoUI = false, -- Set to true if you want to hide from the Keybind menu,

	-- Occurs when the keybind is clicked, Value is `true`/`false`
	Callback = function(Value)



	end,

	-- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
	ChangedCallback = function(New)
	end
})
PlayerBox:AddDivider()
PlayerBox:AddToggle('EnableJump',{
	Text='Enable Jump',Default=false,Callback=function(v)
		Character:SetAttribute('CanJump',v)
	end
})


PlayerBox:AddToggle('NoSlowDown',{
	Text='No Acceleration',Default=false,Callback=function(v)
		for _, HumanoidRootPart in pairs(LocalPlayer.Character:GetDescendants()) do
			if HumanoidRootPart:IsA("BasePart") then
				CustomPhysicalProperties = HumanoidRootPart.CustomPhysicalProperties
				if v then
					HumanoidRootPart.CustomPhysicalProperties = PhysicalProperties.new(100, CustomPhysicalProperties,CustomPhysicalProperties)
				else HumanoidRootPart.CustomPhysicalProperties = CustomPhysicalProperties
				end
			end
		end
	end
})

Players = game:GetService("Players")
RunService = game:GetService("RunService")

player = Players.LocalPlayer
local offsetX, offsetY, offsetZ = 0, 0, 0
local heartbeatConnection = nil
local thingy = nil

ESPSettings:AddSlider('ToolOffsetX', {
	Text = 'Viewmodel X',
	Min = -10,
	Max = 10,
	Default = 0,
	Rounding = 2,
	Callback = function(v) offsetX = v end,
})

ESPSettings:AddSlider('ToolOffsetY', {
	Text = 'Viewmodel Y',
	Min = -10,
	Max = 10,
	Default = 0,
	Rounding = 2,
	Callback = function(v) offsetY = v end,
})

ESPSettings:AddSlider('ToolOffsetZ', {
	Text = 'Viewmodel Z',
	Min = -10,
	Max = 10,
	Default = 0,
	Rounding = 2,
	Callback = function(v) offsetZ = v end,
})

ESPSettings:AddToggle('ToolOffset', {
	Text = 'Viewmodel',
	Default = false,
	Callback = function(enabled)
		local gui = player:FindFirstChild("PlayerGui")
		if not gui then return end
		local moduleGui = gui:FindFirstChild("MainUI")
		if not moduleGui then return end
		moduleGui = moduleGui:FindFirstChild("Initiator")
		if not moduleGui then return end
		moduleGui = moduleGui:FindFirstChild("Main_Game")
		if not moduleGui then return end

		thingy = require(moduleGui)

		if enabled then
			if heartbeatConnection then heartbeatConnection:Disconnect() end
			heartbeatConnection = RunService.Heartbeat:Connect(function()
				thingy.tooloffset = Vector3.new(offsetX, offsetY, offsetZ)
			end)
		else
			if heartbeatConnection then
				heartbeatConnection:Disconnect()
				heartbeatConnection = nil
			end
			if thingy then
				thingy.tooloffset = Vector3.new(0, 0, 0)
			end
		end
	end
})
ESPSettings:AddDivider()

Players = game:GetService("Players") RunService = game:GetService("RunService") ReplicatedStorage = game:GetService("ReplicatedStorage") Workspace = game:GetService("Workspace") local LocalPlayer = Players.LocalPlayer local WorkspaceCamera = Workspace.CurrentCamera local screechCon = nil local hearingCon = nil local eyesCon = nil local lookmanCon = nil AntiBox:AddToggle("AntiScreech", { Text    = "Disables Screech", Default = false, Tooltip = "Prevent Screech From Spawning", Callback = function(enabled) if screechCon then screechCon:Disconnect() screechCon = nil end if enabled then local camKids = WorkspaceCamera:GetChildren() for i = 1, #camKids do if camKids[i].Name == "GlitchedScreech" then camKids[i]:Destroy() end end screechCon = WorkspaceCamera.ChildAdded:Connect(function(child) if child.Name == "GlitchedScreech" then child:Destroy() end end) local mods = LocalPlayer.PlayerGui :WaitForChild("MainUI") :WaitForChild("Initiator") :WaitForChild("Main_Game") :WaitForChild("RemoteListener") :WaitForChild("Modules") local mod = mods:FindFirstChild("Screech") or mods:FindFirstChild("_Screech") if mod then mod.Name = "_Screech" end else local mods = LocalPlayer.PlayerGui :WaitForChild("MainUI") :WaitForChild("Initiator") :WaitForChild("Main_Game") :WaitForChild("RemoteListener") :WaitForChild("Modules") local mod = mods:FindFirstChild("_Screech") or mods:FindFirstChild("Screech") if mod then mod.Name = "Screech" end end end }) AntiBox:AddToggle("AntiDread", { Text    = "Disables Dread", Default = false, Tooltip = "Prevent Dread From Spawning", Callback = function(enabled) local mods = LocalPlayer.PlayerGui :WaitForChild("MainUI") :WaitForChild("Initiator") :WaitForChild("Main_Game") :WaitForChild("RemoteListener") :WaitForChild("Modules") local mod = mods:FindFirstChild("Dread") or mods:FindFirstChild("_Dread") if mod then mod.Name = enabled and "_Dread" or "Dread" end end }) 
AntiBox:AddDivider()
local THROTTLE = 0.1 AntiBox:AddToggle("AntiFigureHearing", { Text    = "Anti Figure Hearing", Default = false, Callback = function(enabled) if hearingCon then hearingCon:Disconnect() hearingCon = nil end if enabled then local acc = 0 hearingCon = RunService.Heartbeat:Connect(function(dt) acc = acc + dt if acc < THROTTLE then return end acc = 0 local remotes = ReplicatedStorage:FindFirstChild("RemotesFolder") remotes = remotes and remotes:FindFirstChild("Crouch") if remotes then remotes:FireServer(true) end end) else local remotes = ReplicatedStorage:FindFirstChild("RemotesFolder") remotes = remotes and remotes:FindFirstChild("Crouch") if remotes then remotes:FireServer(false) end end end }) FloorsBox:AddToggle("AntiA90", { Text    = "Disables A90", Default = false, Callback = function(enabled) local mods = LocalPlayer.PlayerGui :WaitForChild("MainUI") :WaitForChild("Initiator") :WaitForChild("Main_Game") :WaitForChild("RemoteListener") :WaitForChild("Modules") local mod = mods:FindFirstChild("A90") or mods:FindFirstChild("_A90") if mod then mod.Name = enabled and "_A90" or "A90" end end }) 
FloorsBx:AddDivider()
local replicatedstorage = game:GetService("ReplicatedStorage")
local workspace = game:GetService("Workspace")
local runservice = game:GetService("RunService")

local eyescon
local remotes = replicatedstorage:FindFirstChild("EntityInfo") or replicatedstorage:FindFirstChild("RemotesFolder") or replicatedstorage:FindFirstChild("Bricks")
local motor = remotes:FindFirstChild("MotorReplication")


AntiBox:AddToggle("Anti-Eyes", {
	Text = "Anti-Eyes",
	Default = false,
	Callback = function(state)
		if eyescon then
			eyescon:Disconnect()
			eyescon = nil
		end
		if not state then return end

		eyescon = runservice.Heartbeat:Connect(function()
			if workspace:FindFirstChild("Eyes") then
				if ReplicatedStorage:FindFirstChild("EntityInfo") or ReplicatedStorage:FindFirstChild("Bricks") then
motor:FireServer(0,-760,0,false)
else
motor:FireServer(-760)
end
			end
		end)
	end
})
    FloorsBox:AddToggle("Anti-Lookman", {
        Text = "Anti-Lookman",
        Default = false,
        Callback = function(enabled)
            if lookmanCon then
                lookmanCon:Disconnect()
                lookmanCon = nil
            end
            if enabled then
                
                lookmanCon = RunService.Heartbeat:Connect(function(dt)
                    
                    if Workspace:FindFirstChild("BackdoorLookman") then
                        motor:FireServer(-760)
                    end
                end)
            end
        end
    })


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

-- Parts to ignore during noclip
local NoclipIgnoreTable = {
	"Collision",
	"_Collision"
}

-- Helper: is the part one we should ignore for noclip?
local function isIgnored(part)
	return table.find(NoclipIgnoreTable, part.Name)
end

-- Noclip loop (initially disconnected)
local NoclipConnection = nil

-- Toggle (via your UI system)
PlayerBox:AddDivider()
PlayerBox:AddToggle("Noclip", {
	Text = "Noclip",
	Default = false,
	Callback = function(enabled)
		if enabled then
LocalPlayer.Character.HumanoidRootPart.CanCollide = false
			-- Start noclip loop
			NoclipConnection = RunService.Heartbeat:Connect(function()
				for _, part in ipairs((LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()):GetDescendants()) do
					if part:IsA("BasePart") then
						if not isIgnored(part) and part.Name ~= "CollisionCrouch" then
							part.CanCollide = false
						elseif part.Name == "CollisionCrouch" then
							part.CanCollide = (part.CollisionGroup == "PlayerCrouching")
						end
					end
				end
			end)
		else
LocalPlayer.Character.HumanoidRootPart.CanCollide = true
			-- Stop noclip
			if NoclipConnection then
				NoclipConnection:Disconnect()
				NoclipConnection = nil
			end

			-- Reset collisions
			for _, part in ipairs((LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()):GetDescendants()) do
				if part:IsA("BasePart") then
					if not isIgnored(part) and part.Name ~= "CollisionCrouch" then
						part.CanCollide = true
					elseif part.Name == "CollisionCrouch" then
						part.CanCollide = (part.CollisionGroup == "PlayerCrouching")
					end
				end
			end
		end
	end
}):AddKeyPicker('Noclip Keybind', {


	Default = 'N', -- String as the name of the keybind (MB1, MB2 for mouse buttons)
	SyncToggleState = true,


	-- You can define custom Modes but I have never had a use for it.
	Mode = 'Toggle', -- Modes: Always, Toggle, Hold

	Text = 'Noclip', -- Text to display in the keybind menu
	NoUI = false, -- Set to true if you want to hide from the Keybind menu,

	-- Occurs when the keybind is clicked, Value is `true`/`false`
	Callback = function(Value)



	end,

	-- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
	ChangedCallback = function(New)
	end
})
local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
		local Collision = char:FindFirstChild("Collision")
		con = RunService.RenderStepped:Connect(function()

char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
if char then
 Collision = char:FindFirstChild("Collision")
C = char:FindFirstChild("_Collision")
if Collision then
		Collision.CanCollide = false

		end
if C then
C.CanCollide = false
end
end
		end)
-- Services (globals as per preference)
-- Services

FloorsBox:AddToggle("AntiSnare", {
	Text = "Anti Snare",
	Tooltip = "You become immune to Snare traps",
	Default = false,
Callback = function(Value)
for _, v in pairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "Snare" then
v:WaitForChild("Hitbox",9e9).CanTouch = false
end
end
end
})


-- Dupe

FloorsBox:AddToggle("AntiDupe", {
	Text = "Anti Dupe",
	Tooltip = "You become immune to Sideroom Dupe",
	Default = false,
	Callback = function(Value)
for _, v in pairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "DoorFake" then
v:WaitForChild("Collision",5).CanTouch = not Toggles.AntiDupe.Value
end
end
end
})
FloorsBox:AddToggle("AntiBanana", {
	Text = "Anti Banana",
	Tooltip = "You become immune to Banana",
	Default = false,
	Callback = function(Value)
for _, v in pairs(workspace:GetChildren()) do
if v.Name == "BananaPeel" then
v.CanTouch = false
end
end
end
})
FloorsBox:AddToggle("AntiJeff", {
	Text = "Anti Jeff ",
	Tooltip = "You become immune to Jeff",
	Default = false,
	Callback = function(Value)
for _, v in pairs(workspace:GetChildren()) do
if v.Name == "JeffTheKiller" then
for _, part in pairs(v:GetChildren()) do
if part:IsA("BasePart") then
part.CanTouch = false
end
end
end
end
end
})
FloorsBox:AddToggle("AntiVacuum", {
	Text = "Anti Vacuum",
	Tooltip = "You become immune to Vacuum",
	Default = false,
	Callback = function(Value)
for _, v in pairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "SideroomSpace" then
for _, part in pairs(v:GetChildren()) do
if part:IsA("BasePart") then
part.CanTouch = false
end
end
end
end
end
})
FloorsBox:AddToggle("AntiGloomPile", {
	Text = "Anti GloomPile",
	Tooltip = "You become immune to GloomPile",
	Default = false,
	Callback = function(Value)
for _, v in pairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "GloomPile" then
for _, part in pairs(v:GetChildren()) do
if part:IsA("BasePart") then
part.CanTouch = false
end
end
end
end
end
})
FloorsBox:AddToggle("AntiLava", {
	Text = "Anti Lava",
	Tooltip = "You become immune to Lava",
	Default = false,
	Callback = function(Value)
for _, v in pairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "Lava" then
v.CanTouch = false
end
end
end
})
FloorsBox:AddToggle("AntiScaryWall", {
	Text = "Anti ScaryWall",
	Tooltip = "You become immune to ScaryWall",
	Default = false,
	Callback = function(Value)

for _, v in pairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "ScaryWall" then
for _, part in pairs(v:GetChildren()) do
if part:IsA("BasePart") then
part.CanTouch = false
end
end
end
end
end
})
FloorsBox:AddToggle("AntiGiggle", {
	Text = "Anti Giggle",
	Tooltip = "You become immune to GiggleCeiling",
	Default = false,
Callback = function(Value)
for _, v in pairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "GiggleCeiling" then
v:WaitForChild("Hitbox",5).CanTouch = not Toggles.AntiGiggle.Value
end
end
end
})

-- Seek Obstacles

FloorsBx:AddToggle("AntiSeek", {
	Text = "Anti Seek Obstacles",
	Default = false,
	Callback = function(Value)
		for _, v in pairs(workspace.CurrentRooms:GetDescendants()) do
			if v.Name == "Seek_Arm" or v.Name == "ChandelierObstruction" then
				for _, part in pairs(v:GetChildren()) do
					if part:IsA("BasePart") then
						part.CanTouch = not Value
					end
				end
			end
		end
	end
})

-- Services
RepStore = game:GetService("ReplicatedStorage")
PS       = game:GetService("Players")
RunSvc   = game:GetService("RunService")

-- Player and GUI
LocalPlayer = PS.LocalPlayer
PlayerGui   = LocalPlayer:WaitForChild("PlayerGui")

-- Locate PL event/function
function findPL()
	local desc = RepStore:GetDescendants()
	for i = 1, #desc do
		local inst = desc[i]
		if inst.Name == "PL" and (inst:IsA("RemoteEvent") or inst:IsA("RemoteFunction")) then
			return inst, inst:IsA("RemoteFunction")
		end
	end
end

PL, isFunction = findPL()

-- Parse UI paper into code string
function parsePaper(paper, hintsContainer)
	local children = paper.UI:GetChildren()
	local map, order = {}, {}

	for i = 1, #children do
		local c = children[i]
		local idx = tonumber(c.Name)
		if idx then
			local key = c.ImageRectOffset.X .. "_" .. c.ImageRectOffset.Y
			map[key] = { idx, "" }
			order[idx] = key
		end
	end

	if hintsContainer then
		local hints = hintsContainer:GetChildren()
		for i = 1, #hints do
			local ic = hints[i]
			if ic.Name == "Icon" then
				local key = ic.ImageRectOffset.X .. "_" .. ic.ImageRectOffset.Y
				local entry = map[key]
				if entry then
					local lbl = ic:FindFirstChildWhichIsA("TextLabel")
					if lbl then entry[2] = lbl.Text end
				end
			end
		end
	end

	local parts = {}
	for i = 1, #order do
		parts[i] = map[ order[i] ][2]
	end
	return table.concat(parts)
end

-- Generic auto-code manager
function manageToggle(toggleName, mode)
	local heartbeatConn
	local throttle = 0
	local seenPapers = {}
	local lastCodes   = {}

	local function stopAll()
		if heartbeatConn then
			heartbeatConn:Disconnect()
			heartbeatConn = nil
		end
		throttle = 0
		table.clear(seenPapers)
		table.clear(lastCodes)
	end

	AutoBox:AddToggle(toggleName, {
		Text    = (mode == "Fire") and "Auto Library Code " or "Notify Library Code",
		Default = false,
		Tooltip = (mode == "Fire")
			and "Automatically  Solve Padlock"
			or "Sent Library Code At Notification",
		Callback = function(enabled)
			stopAll()
			if not enabled then return end

			local function onHeartbeat(dt)
				throttle = throttle + dt
				if throttle < 0.3 then return end
				throttle = 0

				local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
				local hints = PlayerGui:FindFirstChild("PermUI")
					and PlayerGui.PermUI:FindFirstChild("Hints")

				-- collect new papers
				local desc = char:GetDescendants()
				for i = 1, #desc do
					local d = desc[i]
					if (d.Name == "LibraryHintPaper" or d.Name == "LibraryHintPaperHard")
						and not seenPapers[d] then
						seenPapers[d] = true
					end
				end

				-- process each paper
				for paper in pairs(seenPapers) do
					if not paper.Parent then
						seenPapers[paper] = nil
						lastCodes[paper]   = nil
					else
						local code = parsePaper(paper, hints)
						if code ~= lastCodes[paper] then
							lastCodes[paper] = code
							if mode == "Fire" then
								if isFunction then
									PL:InvokeServer(code)
								else
									PL:FireServer(code)  -- î¨پ0î¨‚
								end
							else
								Library:Notify("[Notify Library Code] Code is "..code, 3)
							end
						end
					end
				end
			end

			heartbeatConn = RunSvc.Heartbeat:Connect(onHeartbeat)
		end,
	})
end

-- Initialize toggles
manageToggle("AutoCodeFire",   "Fire")
AutoBox:AddDivider()
manageToggle("AutoCodeNotify", "Notify")

local noCamShakeConn
local mod

ESPSettings:AddToggle('No CamShake', {
	Text    = "No CamShake",
	Tooltip = "Stops Camera Shake",

	Default = false,
	Callback = function(enabled)
		if enabled then
			-- First-time setup: ensure require() exists and grab the module
			if typeof(require) ~= "function" then
				warn("Require not supported here")
				return
			end
			mod = require(
				Players.LocalPlayer
					.PlayerGui
					.MainUI
					.Initiator
					.Main_Game
			)

			-- Now hook Heartbeat: each frame just zero csgo
			noCamShakeConn = RunService.Heartbeat:Connect(function()
				mod.csgo = CFrame.new()
			end)
		else
			-- Disconnect and clear module reference
			if noCamShakeConn then
				noCamShakeConn:Disconnect()
				noCamShakeConn = nil
			end
			mod = nil
		end
	end,
})
local loopcon
local staticignored = {
	HidePrompt = true,
	ClimbPrompt = true,
	PushPrompt = true,
	InteractPrompt = true,
	PropPrompt = true,
	StarRiftPrompt = true,
RevivePrompt = true,
	RiftPrompt = true,
UnlockPrompt = true,
FusesPrompt = true,
SkullPrompt = true

}

local ignoredparents = {
	Padlock = true,
	Seek_Arm = true,
	KeyObtainFake = true,
   ChandelierObstruction  = true,
AlarmClockModel = true,
Model = true,

}

local validprompts = {}


local function isvalidprompt(inst)
	if not inst:IsA("ProximityPrompt") then return false end

	if staticignored[inst.Name] then return false end
	local p = inst.Parent
	if not p or ignoredparents[p.Name] then return false end
	return true
end

local function getvalidprompts()
	table.clear(validprompts)
	for _, inst in ipairs(workspace.CurrentRooms:GetDescendants()) do
		if isvalidprompt(inst) then
			validprompts[#validprompts+1] = inst
		end
	end
end
local isfool = game.ReplicatedStorage.GameData.Floor.Value == "Fools"

function firepromptsnear()
RunService.Heartbeat:Wait(0.15)
	if not LocalPlayer.Character then return end
	for _, prompt in ipairs(validprompts) do
		if prompt.Parent then
			if not (isfool and prompt.Name == "GoldPile") then
if ((prompt:GetAttribute("Interactions") or 0) < 1) then
				local part = prompt.Parent:IsA("BasePart") and prompt.Parent or prompt.Parent:FindFirstChildWhichIsA("BasePart")
				if part and (part.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude <= 12.5 then
					fireproximityprompt(prompt)
					
				end
			end
end
		end
	end
end
local loopcon = nil
AutoBox:AddToggle("AutoInteract", {
	Text = "Auto Interact",
	Default = false,

	Callback = function(v)
		if v then
			getvalidprompts()
			loopcon = RunService.Heartbeat:Connect(firepromptsnear)
		else
			if loopcon then loopcon:Disconnect() loopcon = nil end
			table.clear(validprompts)
		end
	end
}):AddKeyPicker("Auto Interact Keybind", {
	Default = "R",
	SyncToggleState = true,
	Mode = "Toggle",
	Text = "Auto Interact",
	NoUI = false,
	Callback = function(v) end,
	ChangedCallback = function(n) end
})
AutoBox:AddDivider()
AutoBox:AddToggle("InteractInstant", {
	Text = "Interact Instant",
	Default = false,
	Callback = function(v)
		if not v then return end
		for _, inst in ipairs(workspace.CurrentRooms:GetDescendants()) do
			if  inst:IsA("ProximityPrompt") then
				inst.HoldDuration = 0
			end
		end
	end
})


-- FullBright toggle
do
    -- Store default Lighting settings to restore on untoggle
    local defaultSettings = {
        GlobalShadows        = Lighting.GlobalShadows,
        Brightness           = Lighting.Brightness,
        ClockTime            = Lighting.ClockTime,
        FogEnd               = Lighting.FogEnd,
        OutdoorAmbient       = Lighting.OutdoorAmbient,
        ExposureCompensation = Lighting.ExposureCompensation,
    }
    local fbConn = nil

    local function applyFullBright()
        Lighting.GlobalShadows        = false
        Lighting.Brightness           = 1.5
        Lighting.ClockTime            = 14
        Lighting.FogEnd               = 1e6
        Lighting.OutdoorAmbient       = Color3.fromRGB(192,192,192)
        Lighting.ExposureCompensation = 0.25
    end

    local function restoreDefaultBright()
        Lighting.GlobalShadows        = defaultSettings.GlobalShadows
        Lighting.Brightness           = defaultSettings.Brightness
        Lighting.ClockTime            = defaultSettings.ClockTime
        Lighting.FogEnd               = defaultSettings.FogEnd
        Lighting.OutdoorAmbient       = defaultSettings.OutdoorAmbient
        Lighting.ExposureCompensation = defaultSettings.ExposureCompensation
    end

    ESPSettings:AddToggle('FullBright', {
        Text    = 'FullBright',
        Default = false,
        Callback = function(on)
            -- Disconnect previous listener
            if fbConn then
                fbConn:Disconnect()
                fbConn = nil
            end
            -- Restore defaults first
            restoreDefaultBright()

            if on then
                -- Apply fullbright immediately
                applyFullBright()
                -- Listen for changes to Lighting properties to reapply if something overrides
                fbConn = Lighting.Changed:Connect(function(prop)  -- 
                    if prop == "GlobalShadows"
                       or prop == "Brightness"
                       or prop == "ClockTime"
                       or prop == "FogEnd"
                       or prop == "OutdoorAmbient"
                       or prop == "ExposureCompensation" then
                        applyFullBright()
                    end
                end)
            end
        end
    })
end

local AntiHeartbeat = false 
old = hookmetamethod(game,"__namecall",newcclosure(function(self,...)
if AntiHeartbeat and getnamecallmethod() == "FireServer" and self.Name == "ClutchHeartbeat" then return false end
return old(self,...)
end))
AutoBox:AddToggle("AntiHeartbeatMiniGame", {
	Text = "Auto Heartbeat Minigame",
	Default = false,
	Callback = function(state)
		AntiHeartbeat = state

end
})

BypassBox:AddToggle("SpeedBypass", {
	Text = "Speed Bypass",
	Default = false,
	Tooltip = "Bypasses game speed anticheat",
	Callback = function(Value)
		SpeedBypassValue = Value
if not LocalPlayer.Character:FindFirstChild("_Collision") then
ClonedCollision = LocalPlayer.Character.Collision:Clone()
ClonedCollision.Parent = LocalPlayer.Character
ClonedCollision.Name = "_Collision"
ClonedCollision.Massless = true
ClonedCollision.CanCollide = false
end 

		SpeedSlider:SetMax(SpeedBypassValue and 75 or 21.4)

		while SpeedBypassValue do
			task.wait(0.205)

			if LocalPlayer.Character.HumanoidRootPart.Anchored then
				ClonedCollision.Massless = true
				task.wait(0.35)
			else
				
				ClonedCollision.Massless = true
				task.wait(0.205)
				ClonedCollision.Massless = false
			end

			if not SpeedBypassValue then
				
				ClonedCollision.Massless = true
				break
			end
end 
	end
})
BypassBox:AddDivider()
-- SERVICES
RepStorage = game:GetService("ReplicatedStorage")
Players = game:GetService("Players")
RunService = game:GetService("RunService")

player = Players.LocalPlayer
char = player.Character or player.CharacterAdded:Wait()
collision = nil
Invisibility = false

entityinfo = game.ReplicatedStorage:FindFirstChild("EntityInfo")
originalCollisionPos = {}
offset = 2.3
inGodmode = false


function updatechar(newchar)
	char = newchar
	collision = nil
	animator = nil
	char:WaitForChild("HumanoidRootPart", 3)
	collision = char:FindFirstChild("Collision")
	local animfolder = char:FindFirstChild("Animations")
	if animfolder then
		crouchanim = animfolder:FindFirstChild("Crouch")
	end
	local humanoid = char:FindFirstChildOfClass("Humanoid")
	if humanoid then
		animator = humanoid:FindFirstChildOfClass("Animator")
	end
end

player.CharacterAdded:Connect(updatechar)
if char then updatechar(char) end



Godmode = BypassBox:AddToggle("Godmode", {
	Text = "God Mode",
	Default = false,
	Tooltip = "Make you Invincible To Entities",
	Callback = function(enabled)
		inGodmode = enabled
if inGodmode then
LocalPlayer.Character.Collision.Position = LocalPlayer.Character.Collision.Position - Vector3.new(0, offset,0)
else
LocalPlayer.Character.Collision.Position = LocalPlayer.Character.Collision.Position + Vector3.new(0,offset,0)
      end
end
}):AddKeyPicker('Avoid Entities Keybind', {


	Default = 'G', -- String as the name of the keybind (MB1, MB2 for mouse buttons)
	SyncToggleState = true,


	-- You can define custom Modes but I have never had a use for it.
	Mode = 'Toggle', -- Modes: Always, Toggle, Hold

	Text = 'God Mode', -- Text to display in the keybind menu
	NoUI = false, -- Set to true if you want to hide from the Keybind menu,

	-- Occurs when the keybind is clicked, Value is `true`/`false`
	Callback = function(Value)



	end,

	-- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
	ChangedCallback = function(New)
	end
})
-- Ensure connection storage exists



local Players    = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace  = game:GetService("Workspace")

local player    = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Whenever the character respawns, re-assign hrp and update filter:
local hrp = character:WaitForChild("HumanoidRootPart")

-- Constants
local RAY_DIST         = 5
local TELEPORTS        = 1     -- exactly six teleports
local COOLDOWN         = 0.2
local THROTTLE_INTERVAL = 0.1     -- seconds between raycasts

-- Name of the â€œfake collisionâ€‌ part inside character


-- State
local bypassActive = false
local debounce     = false
local rayCon, enforceCon

-- RaycastParams (weâ€™ll exclude the character itself)
local rayParams = RaycastParams.new()
rayParams.FilterType  = Enum.RaycastFilterType.Exclude
rayParams.IgnoreWater = true

local function updateFilter()
	rayParams.FilterDescendantsInstances = { character }
end

-- Call once at start
updateFilter()

-- If the player dies/respawns, re-hook hrp & filter
player.CharacterAdded:Connect(function(newChar)
	character = newChar
	hrp = character:WaitForChild("HumanoidRootPart")
	updateFilter()
end)

-- List of object-names to ignore in front of us
local ignoreNames = {
	["Door"]               = true,
	["DoorNormal"]         = true,
	["Luggage_Cart_Crouch"]= true,
	-- add any other parent-names here
}

-- Teleport batch + schedule cooldown
local function triggerBypass()
	debounce = true

	-- Perform six quick teleport â€œnudgesâ€‌ along our look vector
	for i = 1, TELEPORTS do
		if not bypassActive then
			break
		end

		local collisionPart = character:FindFirstChild("Collision")
		local cframe = collisionPart.CFrame
		if collisionPart then
			-- move â€œCollisionâ€‌ far forward for one frame
			collisionPart:PivotTo(collisionPart.CFrame * CFrame.new(0, 0, 5000))
		end

		-- wait one physics frame
		RunService.Heartbeat:Wait()
	end

	-- Stop enforcing â€œMassless = falseâ€‌ after 1 second
	task.delay(0.09, function()
	if collisionPart then
	collisionPart:PivotTo(cframe)
		if enforceCon then
			enforceCon:Disconnect()
			enforceCon = nil
			end
		end
	end)

	-- Cooldown before next trigger
	task.delay(COOLDOWN, function()
		debounce = false
	end)
end

-- Per-frame enforcement: keep â€œfakecollisionâ€‌ Massless = false
function onEnforce()
	if not bypassActive then
		if enforceCon then
			enforceCon:Disconnect()
			enforceCon = nil
		end
		return
	end

	
end

-- Throttled raycast check
throttleAccum = 0
local function onRayCheck(dt)
	if debounce then
		return
	end

	throttleAccum = throttleAccum + dt
	if throttleAccum < THROTTLE_INTERVAL then
		return
	end
	throttleAccum = 0

	if not hrp or not hrp.Parent then
		return
	end

	-- Prepare origin & direction
	origin    = hrp.Position
	direction = hrp.CFrame.LookVector * RAY_DIST

	hitResult = Workspace:Raycast(origin, direction, rayParams)
	if hitResult and hitResult.Instance:IsA("BasePart") then
		-- If the hitâ€™s parent model/name is in ignoreNames, skip
		local parentName = hitResult.Instance.Parent and hitResult.Instance.Parent.Name
		if not ignoreNames[parentName] then
			-- Something valid is blocking within RAY_DIST â†’ trigger bypass
			triggerBypass()

			-- Start enforcing Massless=false each frame if not done already
			if not enforceCon then
				enforceCon = RunService.Heartbeat:Connect(onEnforce)
			end
		end
	end
end

-- GUI toggle hookup (replace `BypassBox` with your actual UI container)
BypassBox:AddToggle("NB", {
	Text    = "Noclip Bypass",
	Default = false,
	Callback = function(on)
		bypassActive = on
		debounce     = false
		throttleAccum = 0

		if on then
			updateFilter()

			-- Disconnect prior ray connection if any
			if rayCon then
				rayCon:Disconnect()
				rayCon = nil
			end

			-- Connect heartbeat for throttled raycasts
			rayCon = RunService.Heartbeat:Connect(onRayCheck)
		else
			-- Turn off everything
			if rayCon then
				rayCon:Disconnect()
				rayCon = nil
			end
			if enforceCon then
				enforceCon:Disconnect()
				enforceCon = nil
			end
			debounce = false
		end
	end,
}):AddKeyPicker('NB Keybind', {


	Default = 'B', -- String as the name of the keybind (MB1, MB2 for mouse buttons)
	SyncToggleState = true,


	-- You can define custom Modes but I have never had a use for it.
	Mode = 'Toggle', -- Modes: Always, Toggle, Hold

	Text = 'Noclip Bypass', -- Text to display in the keybind menu
	NoUI = false, -- Set to true if you want to hide from the Keybind menu,

	-- Occurs when the keybind is clicked, Value is `true`/`false`
	Callback = function(Value)



	end,

	-- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
	ChangedCallback = function(New)
	end
})
BypassBox:AddDivider()


if ReplicatedStorage:FindFirstChild("Bricks") or ReplicatedStorage:FindFirstChild("EntityInfo") then
	local DeleteFE = false
	local deleteCoroutine

	FloorsBx:AddToggle("DeleteSeekFE", {
		Text = "Delete Seek (FE)",
		Default = false,
		Tooltip = "Makes Seek never appear",
		Callback = function(Value)
			DeleteFE = Value

			if deleteCoroutine and coroutine.status(deleteCoroutine) ~= "dead" then
				DeleteFE = false
				task.wait(0.3)
			end

			if DeleteFE then
				deleteCoroutine = coroutine.create(function()
					while DeleteFE do
						task.wait(0.3)
						local seek = workspace:FindFirstChild("TriggerSeek", true)
						if seek then seek:Destroy() end
						local evt = workspace:FindFirstChild("TriggerEventCollision", true)
						if evt then evt:ClearAllChildren() end
					end
				end)
				coroutine.resume(deleteCoroutine)
			end
		end
	})
end

if ReplicatedStorage.GameData.Floor.Value == "Retro" then
	local LatestRoom = ReplicatedStorage.GameData.LatestRoom
	local roomDescConn, roomChangeConn

	FloorsBx:AddToggle("AntiFakeBridge", {
		Text = "Remove Fake Bridge",
		Default = false,
		Callback = function(on)
			if roomDescConn then roomDescConn:Disconnect() roomDescConn = nil end
			if roomChangeConn then roomChangeConn:Disconnect() roomChangeConn = nil end
			if not on then return end

			local function removeBridgeParts(room)
				for _, obj in ipairs(room:GetDescendants()) do
					if obj:IsA("BasePart") and obj.Name == "Bridge" and not obj.CanCollide then
						obj:Destroy()
					end
				end
				roomDescConn = room.DescendantAdded:Connect(function(obj)
					if obj:IsA("BasePart") and obj.Name == "Bridge" and not obj.CanCollide then
						obj:Destroy()
					end
				end)
			end

			local function onRoomChanged()
				if roomDescConn then roomDescConn:Disconnect() roomDescConn = nil end
				local room = workspace.CurrentRooms:FindFirstChild(LatestRoom.Value)
				if room then removeBridgeParts(room) end
			end

			onRoomChanged()
			roomChangeConn = LatestRoom.Changed:Connect(onRoomChanged)
		end
	})
end


-- Services
-- Services
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- GameData references
local GameData = ReplicatedStorage:WaitForChild("GameData")
local LatestRoomVal = GameData:WaitForChild("LatestRoom")
local CurrentRooms = Workspace:WaitForChild("CurrentRooms")

-- Utility to get current room model
function currentRoom()
    return CurrentRooms[game.ReplicatedStorage.GameData.LatestRoom.Value]
end

--------------------------------------------------------------------------------
-- Notification Toggles: EntityNotify and Chat Notify (event-driven)
--------------------------------------------------------------------------------
 notifyentities = {
	RushMoving = {"Rush", "Find a hiding spot."},
	AmbushMoving = {"Ambush", "Hide multiple times!"},
	A60 = {"A-60", "Hide immediately!"},
	A120 = {"A-120", "Find A HidingSpot!"},
	JeffTheKiller = {"Jeff", "Keep distance and avoid."},
	SeekMoving = {"Seek", "Run and dodge obstacles!"},
	SeekMovingNewClone = {"Seek", "Run and dodge obstacles!"},
	BackdoorRush = {"Blitz", "Find a hiding spot."},
	GlitchRush = {"GlitchRush", "Find a hiding spot."},
	GlitchAmbush = {"Glitch Ambush", "Find HidingSpot!"},
	GiggleCeiling = {"Giggle", "Avoid it."},
	Eyes = {"Eyes", "Don't look at it."},
	BackdoorLookman = {"Lookman", "Don't look at it."},
	
}

 tracked_notify = {}
 tracked_chat = {}

ESPBox:AddToggle("EntityNotify", {
	Text = "Entities Notify",
	Default = false,
	Callback = function(on)
		for inst in pairs(tracked_notify) do tracked_notify[inst] = nil end

		if on then
			for _, inst in ipairs(workspace:GetDescendants()) do
				if inst:IsA("Model") then
					 data = notifyentities[inst.Name]
					if data and not tracked_notify[inst] then
						tracked_notify[inst] = true
						Library:Notify(("› %s has spawned! %s"):format(data[1], data[2]), 4)
						Sound()
					end
				end
			end
		end
	end
})

ESPBox:AddToggle("ChatNotify", {
	Text = "Chat Notify",
	Default = false,
	Callback = function(on)
		for inst in pairs(tracked_chat) do tracked_chat[inst] = nil end

		if on then
			for _, inst in ipairs(workspace:GetDescendants()) do
				if inst:IsA("Model") then
					 data = notifyentities[inst.Name]
					if data and not tracked_chat[inst] then
						tracked_chat[inst] = true
						ChatNotify(("› %s has spawned! %s"):format(data[1], data[2]))
						Sound()
					end
				end
			end
		end
	end
})
ESPBox:AddDivider()
--------------------------------------------------------------------------------
-- Entity ESP (event-driven)
--------------------------------------------------------------------------------

    EntityNames = {
	RushMoving = "Rush", AmbushMoving = "Ambush", A60 = "A-60", A120 = "A-120",
	BackdoorRush = "Blitz", SallyWindow = "Sally", JeffTheKiller = "Jeff",
	GrumbleRig = "Grumble", GiggleCeiling = "Giggle", Snare = "Snare",
	FigureRig = "Figure", FigureRagdoll = "Figure", BananaPeel = "BananaPeel",
	SeekMovingNewClone = "Seek", SeekMoving = "Seek", GlitchRush = "GlitchRush",
	Eyes = "Eyes", GlitchAmbush = "GlitchAmbush", BackdoorLookman = "Lookman",
	Screech = "Screech", GlitchedScreech = "GlitchedScreech"
}

tracked = {}
State = false
EspCon = nil

function getbasepart(model)
	local function findbase(m)
		for _, v in ipairs(m:GetChildren()) do
			if v:IsA("BasePart") then return v end
			local found = findbase(v)
			if found then return found end
		end
	end

	local part = model:FindFirstChildOfClass("BasePart") or findbase(model)
	repeat
		task.wait()
		part = model:FindFirstChildOfClass("BasePart") or findbase(model)
	until part
	return part
end

function createesp(model)
	if not EntityNames[model.Name] or tracked[model] then return end

	local part = getbasepart(model)
	part.Transparency = 0.99

	local handle = ESPLibrary:AddESP({
		Object = part,
		Text = EntityNames[model.Name],
		Color = Color3.fromRGB(255, 0, 0)
	})

	tracked[model] = handle
end

function removeallesp()
	for model, handle in pairs(tracked) do
		ESPLibrary:RemoveESP(handle)
		tracked[model] = nil
	end
end

ESPBox:AddToggle("EntityESP", {
	Text = "Entities",
	Default = false,
	Callback = function(on)
		State = on

		if EspCon then
			EspCon:Disconnect()
			EspCon = nil
		end

		removeallesp()
		if not State then return end

		local all = workspace:GetDescendants()
		for i = 1, #all do
			local inst = all[i]
			if EntityNames[inst.Name] then
				createesp(inst)
			end
		end
	end
})

--------------------------------------------------------------------------------
local LatestRoomValue = game.ReplicatedStorage.GameData.LatestRoom

local function makeRoomESP(name, matchFn, labelFnOrText, color)
    local tracked = {}
    local addedConn, removingConn, roomChangeConn

    local function addESP(obj)
        if tracked[obj] then return end
        local target
        
            target = (obj.Name == "Door") and obj.PrimaryPart or obj           
       
        if not target then return end
        local textLabel
        if type(labelFnOrText) == "function" then
            local success, result = pcall(function() return labelFnOrText(obj) end)
            textLabel = (success and result) or ""
        else
            textLabel = tostring(labelFnOrText)
        end
        local espHandle = ESPLibrary:AddESP{ Object = target, Text = textLabel, Color = color }
        tracked[obj] = espHandle
    end

    local function removeESP(obj)
        local handle = tracked[obj]
        if handle then
            ESPLibrary:RemoveESP(handle)
            tracked[obj] = nil
        end
    end

     function clearTracked()
        for obj, handle in pairs(tracked) do
            ESPLibrary:RemoveESP(handle)
        end
        table.clear(tracked)
    end

    local function disconnectBound()
        if addedConn then
            addedConn:Disconnect()
            addedConn = nil
        end
        if removingConn then
            removingConn:Disconnect()
            removingConn = nil
        end
    end

    local function bindRoom(room)
        clearTracked()
        disconnectBound()
        if not room then return end
        local descendants = room:GetDescendants()
        for i = 1, #descendants do
            local obj = descendants[i]
            if matchFn(obj) then
                addESP(obj)
            end
        end
    end

    ESPBox:AddToggle(name, {
        Text = name,
        Default = false,
        Callback = function(on)
            if roomChangeConn then
                roomChangeConn:Disconnect()
                roomChangeConn = nil
            end
            disconnectBound()
            clearTracked()
            if not on then return end
            roomChangeConn = LatestRoomValue:GetPropertyChangedSignal("Value"):Connect(function()
    bindRoom(currentRoom())
            end)
            bindRoom(currentRoom())
        end,
    })
end
    

    makeRoomESP(
        "Door",
        function(o) return o:IsA("Model") and o.Name == "Door" end,
        function(o)
if o:FindFirstChild("Lock") then
            
                    return "Locked Door"
                else
            return "Door"
        end
end,
        Color3.fromRGB(0, 0, 255)
    )
    

makeRoomESP("HidingSpot",
    function(o)
        if o.Name == "Wardrobe"
            or o.Name == "Rooms_Locker"
            or o.Name == "Backdoor_Wardrobe"
            or o.Name == "Toolshed"
            or o.Name == "Locker_Large"
            or o.Name == "Bed"
            or o.Name == "CircularVent"
            or o.Name == "Rooms_Locker_Fridge"
            or o.Name == "RetroWardrobe"
            or o.Name == "Dumpster"
            or o.Name == "Double_Bed" then
            return o
        end
    end,
    function(o)
        if o.Name == "Bed" or o.Name == "Double_Bed" then
            return "Bed"
        elseif o.Name == "Rooms_Locker" or o.Name == "Locker_Large" then
            return "Locker"
        elseif o.Name == "Wardrobe" or o.Name == "Backdoor_Wardrobe"
            or o.Name == "Toolshed" or o.Name == "RetroWardrobe" then
            return "Closet"
        elseif o.Name == "CircularVent" then
            return "Hiding Vent"
        elseif o.Name == "Rooms_Locker_Fridge" then
            return "Locker_Fridge"
        elseif o.Name == "Dumpster" then
            return "Dumpster"
        end
    end,
    Color3.fromRGB(0, 255, 0)
)
makeRoomESP("Key",
    function(o)
        if o.Name == "KeyObtain" then
            return o
        end
    end,
    "Key",
    Color3.fromRGB(0, 255, 0)
)
makeRoomESP(
    "Chest",
    function(o)
        return o.Name == "Toolbox" or o.Name == "Toolbox_Locked" or o.Name == "Chest" or o.Name == "Chest_Vine" or o.Name == "Chest_Locked"
    end,
    function(o)
        return o.Name
    end,
    Color3.fromRGB(0, 0, 255)
)
makeRoomESP("Library Books",
    function(o)
        if o:IsA("Model") and o.Name == "LiveHintBook" then
            return o
        end
    end,
    "Book",
    Color3.fromRGB(0, 0, 255)
)

makeRoomESP("Gate Lever",
    function(o)
        if o:IsA("Model") and o.Name == "LeverForGate" then
            return o
        end
    end,
    "Gate Lever",
    Color3.fromRGB(0, 0, 255)
)

makeRoomESP("Breaker",
    function(o)
        if o.Name == "LiveBreakerPolePickup" then
            return o
        end
    end,
    "Breaker",
    Color3.fromRGB(0, 255, 0)
)

makeRoomESP("Timer Lever",
    function(o)
        if o.Name == "TimerLever" then
            return o
        end
    end,
    "TimerLever",
    Color3.fromRGB(0, 0, 255)
)

makeRoomESP("Generator",
    function(o)
        if o.Name == "MinesGenerator" then
            return o
        end
    end,
    "Generator",
    Color3.fromRGB(0, 255, 0)
)

makeRoomESP("Fuse",
    function(o)
        if o.Name == "FuseObtain" then
            return o
        end
    end,
    "Fuse",
    Color3.fromRGB(0, 255, 0)
)

makeRoomESP(
    "Chest",
    function(o)
        return o.Name == "Toolbox" or o.Name == "Toolbox_Locked" or o.Name == "Chest" or o.Name == "Chest_Vine" or o.Name == "Chest_Locked"
    end,
    function(o)
        return o.Name
    end,
    Color3.fromRGB(0, 0, 255)
)
local anchors = {
    {Toggle = "Anchor", Target = "MinesAnchor", Label = "Anchor"},
    {Toggle = "Electrical Key", Target = "ElectricalKeyObtain", Label = "ElectricalKey"},
    {Toggle = "Water Pump", Target = "WaterPump", Label = "WaterPump"},
}
for i = 1, #anchors do
    local a = anchors[i]
    makeRoomESP(a.Toggle,
        function(o)
            if o.Name == a.Target then
                return o
            end
        end,
        a.Label,
        Color3.fromRGB(0, 255, 0)
    )
end


--------------------------------------------------------------------------------
-- Players ESP (pass Model instead of BasePart)
--------------------------------------------------------------------------------

    local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

ESPBox:AddToggle("Players", {
    Text = "Players",
    Default = false,
}):OnChanged(function(on)
    if not on then
        for _, plr in pairs(Players:GetPlayers()) do
            if plr.Character then
                ESPLibrary:RemoveESP(plr.Character)
            end
        end
        return
    end

    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character then
            ESPLibrary:AddESP{
                Object = plr.Character,
                Text = plr.Name,
                Color = Color3.fromRGB(0, 150, 255),
            }
        end
    end
end)

Players.PlayerAdded:Connect(function(plr)
    plr.CharacterAdded:Connect(function(char)
        if not Toggles.Players.Value then return end
        if plr ~= LocalPlayer then
            ESPLibrary:AddESP{
                Object = char,
                Text = plr.Name,
                Color = Color3.fromRGB(0, 150, 255),
            }
        end
    end)
end)
--------------------------------------------------------------------------------
-- Items ESP (model-level)
--------------------------------------------------------------------------------
-- Items ESP (model-level, rebind on LatestRoomVal change)
local tracked = {}
local removingConn, roomChangedConn

local items = {
	"Flashlight", "Lockpick", "Vitamins", "Bandage", "StarVial", "StarBottle", "StarJug",
	"Shakelight", "Straplight", "Bulklight", "Battery", "Candle", "Crucifix", "CrucifixWall",
	"Glowsticks", "SkeletonKey", "Candy", "ShieldMini", "ShieldBig", "BandagePack", "BatteryPack",
	"RiftCandle", "LaserPointer", "HolyGrenade", "Shears", "Smoothie", "Cheese", "Bread",
	"AlarmClock", "RiftSmoothie", "GweenSoda", "GlitchCub"
}

local itemSet = {}
for _, name in ipairs(items) do
	itemSet[name] = true
end

local function clearAll()
	for inst, handle in pairs(tracked) do
		ESPLibrary:RemoveESP(handle)
	end
	tracked = {}
	if removingConn then removingConn:Disconnect() removingConn = nil end
end

local function addItem(inst)
	if tracked[inst] or not inst then return end
	tracked[inst] = ESPLibrary:AddESP{
		Object = inst,
		Text = inst.Name,
		Color = Color3.fromRGB(255, 215, 0),
	}
end

local function removeItem(inst)
	if tracked[inst] then
		ESPLibrary:RemoveESP(tracked[inst])
		tracked[inst] = nil
	end
end

local function scanCurrentRoom()
	clearAll()
	local room = currentRoom()
	if not room then return end
	for _, inst in ipairs(room:GetDescendants()) do
		if itemSet[inst.Name] then addItem(inst) end
	end
	removingConn = room.DescendantRemoving:Connect(removeItem)
end

ESPBox:AddToggle("Items", {
	Text = "Items",
	Default = false,
	Callback = function(on)
		clearAll()
		if roomChangedConn then roomChangedConn:Disconnect() roomChangedConn = nil end
		if not on then return end
		scanCurrentRoom()
		roomChangedConn = LatestRoomVal.Changed:Connect(scanCurrentRoom)
	end
})

-- Gold ESP (model-level, rebind on LatestRoomVal change)
local goldESP = {}

local function clearGoldESP()
	for inst, data in pairs(goldESP) do
		if data.ancestryConn then
			data.ancestryConn:Disconnect()
		end
		if data.handle then
			ESPLibrary:RemoveESP(data.handle)
		end
	end
	goldESP = {}
end

local function addGoldPileESP(inst)
	if goldESP[inst] then return end
	local value = inst:GetAttribute("GoldValue")
	if not value then return end
	local handle = ESPLibrary:AddESP{
		Object = inst,
		Text = "Gold " .. tostring(value),
		Color = Color3.fromRGB(255, 215, 0),
	}
	local ancestryConn = inst.AncestryChanged:Connect(function(_, parent)
		if not parent or not inst:IsDescendantOf(workspace.CurrentRooms) then
			if goldESP[inst] then
				if goldESP[inst].handle then ESPLibrary:RemoveESP(goldESP[inst].handle) end
				if goldESP[inst].ancestryConn then goldESP[inst].ancestryConn:Disconnect() end
				goldESP[inst] = nil
			end
		end
	end)
	goldESP[inst] = {handle = handle, ancestryConn = ancestryConn}
end

ESPBox:AddToggle("Gold", {
	Text = "Gold",
	Default = false,
	Callback = function(on)
		clearGoldESP()
		if not on then return end
for _, v in pairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "GoldPile" then
addGoldPileESP(v)
end
end
		-- no scanning or LatestRoomVal.Changed needed
	end,
})
ESPSettings:AddToggle('Rainbow ESP',{
	Text = "Rainbow Esp",
	Default = false,
	Callback = function(Value)
		ESPLibrary:SetRainbow(Value)
	end
})
ESPSettings:AddToggle('Traces ESP',{
	Text = "Tracers Esp",
	Default = false,
	Callback = function(Value)
		ESPLibrary:SetTracers(Value)
	end
})
ESPSettings:AddToggle('Distance Meters ESP',{
	Text = "Distance Meters Esp",
	Default = false,
	Callback = function(Value)
		ESPLibrary:SetShowDistance(Value)
	end
})
infinitevalue = false
clonedprompts = {}
infinitecheck = nil

function getinstance(name)
	return workspace:FindFirstChild(name, true)
end

function hasValidTool()
	local char = LocalPlayer.Character
	if not char then return false end
	return char:FindFirstChild("Shears") or char:FindFirstChild("Lockpick") or char:FindFirstChild("SkeletonKey")
end

function handleprompt(prompt)
	if not prompt:IsA("ProximityPrompt") or clonedprompts[prompt] then return end

	local n = prompt.Name
	local p = prompt.Parent
	if not p then return end

	if (n == "ActivateEventPrompt" and p.Name == "Chest_Vine") or n == "UnlockPrompt" or n == "FusesPrompt" or n == "SkullPrompt" then
		local clone = prompt:Clone()
		clone.Name = "FakePrompt"
		clone.Parent = p
		clone.Enabled = true
		clone.ClickablePrompt = true

		clonedprompts[prompt] = clone
		prompt.Enabled = false
		prompt.ClickablePrompt = false

		clone.Triggered:Connect(function()
			local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
			if not tool then return end

			local rf = replicatedstorage:FindFirstChild("RemotesFolder")
			if not rf then return end

			local name = tool.Name
			rf.DropItem:FireServer(tool)
			workspace.Drops.ChildAdded:Wait()

			local model = workspace.Drops:FindFirstChild(name)
			if model then
				local dp = model:FindFirstChildOfClass("ProximityPrompt")
				if dp then fireproximityprompt(dp) end
			end

			fireproximityprompt(prompt)
			clonedprompts[prompt] = nil
			clone:Destroy()
		end)
	end
end

function startinfinite()
	infinitecheck = task.spawn(function()
		for _, obj in ipairs(workspace:GetDescendants()) do
			if obj:IsA("ProximityPrompt") then
				handleprompt(obj)
			end
		end

		RunService.Heartbeat:Connect(function()
			for original, clone in pairs(clonedprompts) do
				if not hasValidTool() then
					if clone then clone:Destroy() end
					if original and original:IsDescendantOf(workspace) then
						original.Enabled = true
						original.ClickablePrompt = true
					end
					clonedprompts[original] = nil
				end
			end
		end)

		while infinitevalue do
			for original, clone in pairs(clonedprompts) do
				if not original:IsDescendantOf(workspace) then
					if clone then clone:Destroy() end
					clonedprompts[original] = nil
				end
			end
			task.wait(0.25)
		end
	end)
end

function stopinfinite()
	infinitevalue = false
	if infinitecheck then
		task.cancel(infinitecheck)
		infinitecheck = nil
	end
	for original, clone in pairs(clonedprompts) do
		if clone then clone:Destroy() end
		if original and original:IsDescendantOf(workspace) then
			original.Enabled = true
			original.ClickablePrompt = true
		end
	end
	table.clear(clonedprompts)
end

PlayerBox:AddToggle("InfiniteItems", {
	Text = "Infinite Items",
	Default = false,
	Callback = function(enabled)
		if enabled then
			if not replicatedstorage:FindFirstChild("RemotesFolder") then return end
			infinitevalue = true
			startinfinite()
		else
			stopinfinite()
		end
	end
})
PlayerBox:AddDivider()
ESPSettings:AddSlider('Text Size',{
	Text='Text Size',
	Min=16,Max=26,Default=23,
	Rounding=0,
	Callback=function(v)
		ESPLibrary:SetTextSize(v)
	end
})
ESPSettings:AddDivider()
local Toggle10 = AntiBox:AddToggle('AntiJamming', {
	Text = "Anti-Jamming",
	Default = false,
	Callback = function(state)
local Modifiers = game.ReplicatedStorage:WaitForChild("LiveModifiers")
		if not Modifiers.Jammin then return end
		local mainTrack = game["SoundService"]:FindFirstChild("Main")
		if mainTrack then
			local jamming = mainTrack:FindFirstChild("Jamming")
			if jamming then
				jamming.Enabled = not state
			end
		end

		local mainUI = LocalPlayer:FindFirstChild("PlayerGui")
			and LocalPlayer.PlayerGui:FindFirstChild("MainUI")
		if mainUI then
			local healthGui = mainUI:FindFirstChild("Initiator")
				and mainUI.Initiator:FindFirstChild("Main_Game")
				and mainUI.Initiator.Main_Game:FindFirstChild("Health")
			if healthGui then
				local jamSound = healthGui:FindFirstChild("Jam")
				if jamSound then
					jamSound.Playing = not state
				end
			end
		end
	end
})

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local camera

-- Wait for camera
local function waitForCamera()
	repeat
		camera = Workspace.CurrentCamera
		task.wait(0.2)
	until camera
end

waitForCamera()

local currentFOV = 70
local targetFOV = 70
local fovEnabled = false
local stepping = false
local fovConn

-- Smoothly steps FOV
local function stepFOV()
	if stepping then return end
	stepping = true
	task.spawn(function()
		while stepping and currentFOV ~= targetFOV do
			local delta = targetFOV - currentFOV
			local step = (delta > 0 and 2) or -2
			if math.abs(delta) < 2 then
				step = delta
			end
			currentFOV = currentFOV + step
			camera.FieldOfView = currentFOV
			task.wait(0.009)
		end
		stepping = false
	end)
end

-- Enforce lock
local function startEnforcing()
	if fovConn then fovConn:Disconnect() end
	fovConn = camera:GetPropertyChangedSignal("FieldOfView"):Connect(function()
		if math.abs(camera.FieldOfView - currentFOV) > 0.1 then
			camera.FieldOfView = currentFOV
		end
	end)
	camera.FieldOfView = currentFOV
end

-- Stop lock
local function stopEnforcing()
	if fovConn then
		fovConn:Disconnect()
		fovConn = nil
	end
end

-- Animation tracking
local playingThinkAnimation = false

local function monitorAnimations(character)
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end

	local animator = humanoid:FindFirstChildOfClass("Animator") or humanoid:WaitForChild("Animator", 3)
	if not animator then return end

	local animFolder = character:FindFirstChild("Animations")
	if not animFolder then return end

	local think1 = animFolder:FindFirstChild("Think1")
	local think2 = animFolder:FindFirstChild("Think2")
	if not (think1 or think2) then return end

	-- Store animation IDs for comparison
	local thinkIds = {}
	if think1 and think1:IsA("Animation") then
		table.insert(thinkIds, think1.AnimationId)
	end
	if think2 and think2:IsA("Animation") then
		table.insert(thinkIds, think2.AnimationId)
	end

	-- Function to update FOV when think animations are playing
	local function updateFOVBasedOnPlayingTracks()
		local tracks = animator:GetPlayingAnimationTracks()
		local thinking = false
		for _, track in pairs(tracks) do
			for _, id in pairs(thinkIds) do
				if track.Animation.AnimationId == id then
					thinking = true
					break
				end
			end
			if thinking then break end
		end

		if thinking and not playingThinkAnimation then
			playingThinkAnimation = true
			currentFOV = 70
			camera.FieldOfView = currentFOV
		elseif not thinking and playingThinkAnimation then
			playingThinkAnimation = false
			if fovEnabled then
				currentFOV = targetFOV
				stepFOV()
			end
		end
	end

	-- Check on animation played/stopped
	animator.AnimationPlayed:Connect(updateFOVBasedOnPlayingTracks)
	updateFOVBasedOnPlayingTracks()
end

-- Character added handler
LocalPlayer.CharacterAdded:Connect(function(char)
	waitForCamera()
	if fovEnabled then
		currentFOV = camera.FieldOfView
		startEnforcing()
		stepFOV()
	end
	monitorAnimations(char)
end)

-- Handle camera reset
Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
	waitForCamera()
	if fovEnabled then
		currentFOV = camera.FieldOfView
		startEnforcing()
		stepFOV()
	end
end)

-- Monitor current character if already spawned
if LocalPlayer.Character then
	monitorAnimations(LocalPlayer.Character)
end

-- Slider to set FOV
ESPSettings:AddSlider("FOV", {
	Text = "Field of View",
	Min = 70,
	Max = 120,
	Default = 70,
	Rounding = 0,
	Callback = function(value)
		targetFOV = value
		if fovEnabled and not playingThinkAnimation then
			stepFOV()
		end
	end,
})

-- Toggle to enable/disable FOV override
ESPSettings:AddToggle("EnableFOV", {
	Text = "Enable Field of View",
	Default = false,
	Callback = function(on)
		fovEnabled = on
		waitForCamera()

		if on then
			currentFOV = camera.FieldOfView
			startEnforcing()
			if not playingThinkAnimation then
				stepFOV()
			end
		else
			stopEnforcing()
			targetFOV = 70
			stepFOV()
		end
	end,
})
ESPSettings:AddDivider()
do
	local Lighting     = game:GetService("Lighting")
	local TweenService = game:GetService("TweenService")
	local atmosphere   = Lighting:FindFirstChildOfClass("Atmosphere")

	-- Will hold the original density once we first enable AntiFog
	local cachedDensity = nil

	-- Flag to control the loop
	local antiFogActive = false

	AntiBox:AddToggle("AntiFog", {
		Text    = "Anti Fog",
		Default = false,
		Callback = function(enabled)
			if not atmosphere then
				return
			end

			antiFogActive = enabled

			if enabled then
				-- Cache the original density on first enable
				if cachedDensity == nil then
					cachedDensity = atmosphere.Density
				end

				-- Spawn a single loop that keeps setting Density = 0
				task.spawn(function()
					while antiFogActive do
						-- Tween to zero density
						TweenService:Create(
							atmosphere,
							TweenInfo.new(0.5),
							{ Density = 0 }
						):Play()

						task.wait(0.8)
					end
				end)
			else
				-- Restoring the cached density when disabled
				if cachedDensity then
					TweenService:Create(
						atmosphere,
						TweenInfo.new(0.5),
						{ Density = cachedDensity }
					):Play()
				end
			end
		end,
	})
end
	
-- === DELETE FIGURE (FE) ===
	BypassBox:AddToggle("DeleteFigure", {
	Text = "Delete Figure",
	Default = false,
	Callback = function(on)
		if not isnetworkowner then
			Library:Notify("[Delete Figure] Executor Doesn't Support isnetworkowner it wouldn't work", 4)
			return
		end

		if on then
			if _df_running then return end
			_df_running = true

			white(function()
				while _df_running do
					local figure = getinstance("FigureRig") or getinstance("FigureRagdoll")
					if figure and isnetworkowner(figure.Root) then
						figure:PivotTo(CFrame.new(0, -9999, 0))
					else
						_df_running = false
						break
					end
					task.wait(0.2)
				end
			end)
		else
			_df_running = false
		end
	end
})
	local shade = game:GetService("ReplicatedStorage").ClientModules.EntityModules:FindFirstChild("_Shade")
		or game:GetService("ReplicatedStorage").ClientModules.EntityModules:FindFirstChild("Shade")

	AntiBox:AddToggle('AN',{
		Text = "Anti Halt",
		Default = false,
		Callback = function(on)
			if shade then
				shade.Name = on and "_Shade" or "Shade"
			end
		end
	})
	local Void = game:GetService("ReplicatedStorage").ClientModules.EntityModules:FindFirstChild("_Void")
		or game:GetService("ReplicatedStorage").ClientModules.EntityModules:FindFirstChild("Void")

	AntiBox:AddToggle('AVJ',{
		Text = "Anti Void JumpScare",
		Default = false,
		Callback = function(on)
			if Void then
				Void.Name = on and "_Void" or "Void"
			end
		end
	})
	local Glitch = game:GetService("ReplicatedStorage").ClientModules.EntityModules:FindFirstChild("_Glitch")
		or game:GetService("ReplicatedStorage").ClientModules.EntityModules:FindFirstChild("Glitch")

	AntiBox:AddToggle('AGJ',{
		Text = "Anti Glitch JumpScare",
		Default = false,
		Callback = function(on)
			if Glitch then
				Glitch.Name = on and "_Glitch" or "Glitch"
			end
		end
	})


	-- Find CamLock once, with an indexed loop and early break


	-- Services
	RunService = game:GetService("RunService")
ReplicatedStorage = game:GetService("ReplicatedStorage")
Players = game:GetService("Players")

LocalPlayer = Players.LocalPlayer

CamLockEvents = {}

task.spawn(function()
	local RemotesFolder = ReplicatedStorage:FindFirstChild("Bricks") or ReplicatedStorage:WaitForChild("RemotesFolder")

	local batchMax = 1000
	local all = {}

if RemotesFolder:FindFirstChild("CamLock") then
			table.insert(all, RemotesFolder.CamLock)
		end

	for i = 1, #all, batchMax do
		for j = i, math.min(i + batchMax - 1, #all) do
			table.insert(CamLockEvents, all[j])
		end
		task.wait()
	end
end)

do
	FastValue = Instance.new("BoolValue")
	FastValue.Name = "FastClosetToggle"
	FastValue.Parent = LocalPlayer

	lastDir = Vector3.zero
	fceConn = nil

	BypassBox:AddToggle("FCE", {
		Text = "Closet Exit Fix",
		Default = false,
		Tooltip = "Fixes Where you Cant Exit Closet Instantly After Hiding",
		Callback = function(on)
			FastValue.Value = on
			if fceConn then
				fceConn:Disconnect()
				fceConn = nil
			end

			if on then
				fceConn = RunService.Heartbeat:Connect(function()
					char = LocalPlayer.Character
					humanoid = char and char:FindFirstChild("Humanoid")
					if not humanoid then return end

					dir = humanoid.MoveDirection
					if dir.Magnitude > 0 and lastDir.Magnitude == 0 and char:GetAttribute("Hiding") == true then
						task.delay(0.08, function()
							for i = 1, #CamLockEvents do
								CamLockEvents[i]:FireServer()
							end
						end)
					end
					lastDir = dir
				end)
			end
		end,
	})
end
BypassBox:AddDivider()
	--------------------------------------------------------------------------------
	-- 2) ANTI SEEK FLOOD (ASF) أ¢â‚¬â€‌ one-time disable when room "100" appears
	--------------------------------------------------------------------------------
	----- VARIABLES / SETUP -----

	if ReplicatedStorage.GameData.Floor.Value == "Mines" then
	do
		local conn

		FloorsBx:AddToggle("ASF", {
			Text = "Anti-Seek Flood",
			Default = false,
			Callback = function(on)
				if conn then conn:Disconnect() conn = nil end
				if not on then return end

				conn = RunService.Heartbeat:Connect(function()
					local room = workspace:FindFirstChild("CurrentRooms") and workspace.CurrentRooms:FindFirstChild("100")
					if not room then return end

					local damHandler = room:FindFirstChild("_DamHandler")
					if not damHandler then return end

					local queue = {damHandler}
					local i = 1
					local processed = 0
					local MAX_SCAN = 50

					while i <= #queue and processed < MAX_SCAN do
						local node = queue[i]
						i += 1

						if node:IsA("BasePart") and node.Name == "SeekFloodline" then
							node.CanCollide = false
							node.CanTouch = false
						end

						for _, child in ipairs(node:GetChildren()) do
							queue[#queue + 1] = child
						end

						processed += 1
					end

					conn:Disconnect()
					conn = nil
				end)
			end
		})
	end
end

	--------------------------------------------------------------------------------
	-- 3) ANTI JEFF (AJF) أ¢â‚¬â€‌ track JeffTheKiller models and kill owned ones
	--------------------------------------------------------------------------------

	--------------------------------------------------------------------------------
	-- 4) ANTI BRIDGE FALL (ABF) أ¢â‚¬â€‌ batched initial scan + event-driven barrier clones
	--------------------------------------------------------------------------------
	if ReplicatedStorage.GameData.Floor.Value == "Mines" then
	do
		local clones = {}
		local bridgeConns = {}

		local function makeBarrier(barrier)
			if barrier.Parent:FindFirstChild("AntiBridge") then return end
			local clone = barrier:Clone()
			clone.Name = "AntiBridge"
			clone.Size = Vector3.new(barrier.Size.X, barrier.Size.Y, 30)
			clone.Color = Color3.new(1, 1, 1)
			clone.CFrame = barrier.CFrame * CFrame.new(0, 0, -5)
			clone.Transparency = 0
			clone.Anchored = true
			clone.CanCollide = true
			clone.CanTouch = true
			clone.Parent = barrier.Parent
			table.insert(clones, clone)
		end

		local function processBridge(bridge)
			if bridge:FindFirstChild("AntiBridge") then return end
			for _, part in ipairs(bridge:GetChildren()) do
				if part.Name == "PlayerBarrier" and part.Size.Y == 2.75 and (part.Rotation.X % 180) == 0 then
					makeBarrier(part)
				end
			end
			local conn = bridge.ChildAdded:Connect(function(c)
				if c.Name == "PlayerBarrier" then
					makeBarrier(c)
				end
			end)
			table.insert(bridgeConns, conn)
		end

		FloorsBx:AddToggle("ABF", {
			Text = "Anti-Bridge Fall",
			Default = false,
			Callback = function(on)
				for _, c in ipairs(bridgeConns) do c:Disconnect() end
				bridgeConns = {}
				for _, c in ipairs(clones) do if c and c.Parent then c:Destroy() end end
				clones = {}

				if not on then return end

				task.spawn(function()
					for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
						local parts = room:FindFirstChild("Parts")
						if parts then
							for _, obj in ipairs(parts:GetChildren()) do
								if obj.Name == "Bridge" then
									processBridge(obj)
								end
							end
							local conn = parts.ChildAdded:Connect(function(c)
								if c.Name == "Bridge" then
									processBridge(c)
								end
							end)
							table.insert(bridgeConns, conn)
						end
					end
				end)

				local roomConn = workspace.CurrentRooms.ChildAdded:Connect(function(room)
					task.defer(function()
						local parts = room:WaitForChild("Parts", 3)
						if parts then
							for _, obj in ipairs(parts:GetChildren()) do
								if obj.Name == "Bridge" then
									processBridge(obj)
								end
							end
							local conn = parts.ChildAdded:Connect(function(c)
								if c.Name == "Bridge" then
									processBridge(c)
								end
							end)
							table.insert(bridgeConns, conn)
						end
					end)
				end)
				table.insert(bridgeConns, roomConn)
			end
		})
	end
end
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local Workspace         = game:GetService("Workspace")
	local GameData          = ReplicatedStorage:WaitForChild("GameData")
	local LatestRoomVal     = GameData:WaitForChild("LatestRoom")

	-- Find the breaker remote once
	local BreakerRemote
	local descs = ReplicatedStorage:GetDescendants()
	for i = 1, #descs do
		if descs[i].Name == "EBF" then
			BreakerRemote = descs[i]
			break
		end
	end

	local stopSignal = true

	AutoBox:AddToggle("ABS", {
		Text    = "Auto Breaker Solve",
		Default = false,
		Callback = function(on)
			stopSignal = not on
			if on and BreakerRemote then
				task.spawn(function()
					while not stopSignal do
						-- get the room youâ€™re actually in
						local roomName = tostring(LatestRoomVal.Value)
						local room = Workspace.CurrentRooms:FindFirstChild(roomName)
						if room then
							local door = room:FindFirstChild("DoorToBreakDown")
							if door then
								BreakerRemote:FireServer()
							end
						end
						task.wait(0.1)
					end
				end)
			end
		end,
	})

	--- SERVICES

	-------------------------------------------------------------------
	-- SERVICES
	-------------------------------------------------------------------
	
	
SettingsBox:AddDropdown('Notify Side', {
	Values = {'Left', 'Right'},
	Default = 2,
	Multi = false,
	Text = 'Notify Side',
	Tooltip = 'Make Notification Appears On Left or Right Side.',
	Callback = function(Value)
		Library.NotifySide = Value
	end
})

	SettingsBox:AddToggle("ShowKeybinds", {
		Text = "Show Keybinds",
		Default = false,
		Tooltip = "Toggle the visibility of the keybinds menu",
	}):OnChanged(function()
		Library.KeybindFrame.Visible = Toggles.ShowKeybinds.Value
	end)
	SettingsBox:AddToggle("Dieanleksj", {
		Text = "Disables Roblox Void",
		Default = true,
		Tooltip = "Disables Void",
	}):OnChanged(function()
		workspace.FallenPartsDestroyHeight =0/0
	end)
	SettingsBox:AddToggle("CustomCursor", {
		Text = "Custom Cursor",
		Default = false,
		Tooltip = "Toggle the visibility of the keybinds menu",
	}):OnChanged(function()
		                Library.ShowCustomCursor = Value
	end)
SettingsBox:AddDivider()
SettingsBox:AddDropdown("DPIDropdown", {
        Values = { "50%", "75%", "100%", "125%", "150%", "175%", "200%" },
        Default = "100%",

        Text = "DPI Scale",

        Callback = function(Value)
                Value = Value:gsub("%%", "")
                local DPI = tonumber(Value)

                Library:SetDPIScale(DPI)
        end,
})
SettingsBox:AddLabel("Menu bind"):AddKeyPicker("MenuKeybind", { Default = "RightShift", NoUI = true, Text = "Menu keybind" })
Library.ToggleKeybind = Options.MenuKeybind -- Allows you to have a custom keybind for the menu
	local Contributors = Tabs.UISettings:AddRightGroupbox("Credits")
	Contributors:AddLabel("KardinCat - Creator",true)
	Contributors:AddLabel("bocaj111004 - Developer",true)
	-- UI Settings
	
	ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
	ThemeManager:ApplyToTab(Tabs.UISettings)
	SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })
ThemeManager:SetFolder("Prohax")
SaveManager:SetFolder("Prohax/DOORS")
SaveManager:BuildConfigSection(Tabs.UISettings)
	 Players     = game:GetService("Players")
	 LocalPlayer = Players.LocalPlayer

	local conn
	 ignoreList = {}    -- list of CandyIDs to ignore
	 ignoreSet  = {}    -- for O(1) checks



	--â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“
	-- Toggle: Auto-eat any new Candy tools not in ignoreSet
	--â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“
	AutoBox:AddToggle("AutoEatCandies", {
		Text    = "Auto Eat Candies",
		Tooltip = "Automatically eats candies",
		Default = false,

		Callback = function(enabled)
			if enabled then
				 character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
				conn = character.ChildAdded:Connect(function(child)
					if child:IsA("Tool") and child.Name == "Candy" then

						child.Remote:FireServer()
					end
				end)
			else
				if conn then
					conn:Disconnect()
					conn = nil
				end
			end
		end,
	})
	-- Services
	 

	con = nil
	FigureBodyPositions = {}

	function handleFigureFreezeTarget(figure)
		local primary = figure.PrimaryPart
		repeat task.wait(0.2) until isnetworkowner(primary)
		local bp = Instance.new("BodyPosition", primary)
		bp.MaxForce = Vector3.new(1e30, 1e30, 1e30)
		bp.P = 9999999999
		bp.Position = primary.Position
		FigureBodyPositions[#FigureBodyPositions + 1] = bp
	end

	TrollBox:AddToggle("Figure Freeze", {
		Text    = "Figure Freeze (FE)",
		Default = false,
		Callback = function(Value)
			FigureFreeze = Value
			if Value then
				local room = workspace.CurrentRooms
				local descendants = room:GetDescendants()
				for i = 1, #descendants do
					local v = descendants[i]
					if v.Name == "FigureRig" or v.Name == "FigureRagdoll" then
						handleFigureFreezeTarget(v)
					end
				end
				con = room.DescendantAdded:Connect(function(v)
					if v.Name == "FigureRig" or v.Name == "FigureRagdoll" then
						handleFigureFreezeTarget(v)
					end
				end)
			else
				if con then
					con:Disconnect()
					con = nil
				end
				for i = 1, #FigureBodyPositions do
					local bp = FigureBodyPositions[i]
					if bp and bp.Parent then
						bp:Destroy()
					end
				end
				FigureBodyPositions = {}
			end
		end
	})
TrollBox:AddToggle("TPFigure", {
		Text    = "TP Figure to Latest Door (FE)",
		Default = false,
		Callback = function(Value)
if Value then
if not isnetworkowner then
Library:Notify("[TP Figure] Doesn't work cuz Executor  Doesn't Support isnetworkowner",4)
return
end
while task.wait(0.2) do
if not Toggles.TPFigure.Value then break end
local Figure = getinstance("FigureRig") or getinstance("FigureRagdoll")
if Figure and Figure.Root then
if isnetworkowner(Figure.Root) then
Figure:PivotTo(CFrame.new(workspace.CurrentRooms[game.ReplicatedStorage.GameData.LatestRoom.Value].Door.Door.CFrame))
end
end
end
end
end
})
	con = nil
	RemotesFolder = nil

	TrollBox:AddToggle("Spam MotorReplication (FE)", {
		Text    = "Spam MotorReplication (FE)",
		Default = false,
		Callback = function(Value)
			if Value then
				if ReplicatedStorage:FindFirstChild("EntityInfo") then
					RemotesFolder = ReplicatedStorage.EntityInfo
				else
					RemotesFolder = ReplicatedStorage.RemotesFolder
				end

				con = RunService.Heartbeat:Connect(function()
					RemotesFolder.MotorReplication:FireServer(-198182828, math.random(-12233333, 999999))
				end)
			else
				if con then
					con:Disconnect()
					con = nil
				end
			end
		end
	})
	-- Global tables to track ESP instances and connection

	-- Global variable to hold the active RenderStepped connection (if any)
	UpsideDownConnection = nil

	-- Function: Starts flipping the character upside down every frame
	function StartUpsideDown()
		-- Prevent multiple connections
		if UpsideDownConnection then
			return
		end

		-- Get the local player's character
		Character = game.Players.LocalPlayer.Character
		if not Character then
			return
		end

		-- Cache the part whose Rotation we want to match/override
		RotationPart = Character:FindFirstChild("Collision")
		if not RotationPart then
			return
		end

		-- Connect to RenderStepped for smooth, frame-synced rotation updates
		UpsideDownConnection = game:GetService("RunService").RenderStepped:Connect(function()
			-- Read the current rotation of the Collision part
			rotation = RotationPart.Rotation
			-- Apply the same X and Y rotation, but force Z = -90 to flip upside down
			Character.Rotation = Vector3.new(rotation.X, rotation.Y, -90)
		end)
	end

	-- Function: Stops flipping and resets rotation
	function StopUpsideDown()
		if UpsideDownConnection then
			-- Disconnect the RenderStepped callback
			UpsideDownConnection:Disconnect()
			UpsideDownConnection = nil

			-- Reset the character's rotation to upright (0, 0, 0)
			if Character and Character.Parent then
				Character.Rotation = Vector3.new(0, 0, 0)
			end
		end
	end

	-- AddToggle implementation (FE-safe)


	TrollBox:AddToggle("Upside Down (FE)", {
		Text    = "Upside Down (FE)",
		Default = false,
		Callback = function(enabled)
			if enabled then
				StartUpsideDown()
			else
				StopUpsideDown()
			end
		end
	})
	MiscBox3:AddToggle("No CutScenes", {
		Text    = "Disable CutScenes",
		Default = false,
		Callback = function(enabled)
			if enabled then
				local CutScenes  = game:GetService("Players").LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game.RemoteListener:FindFirstChild("Cutscenes") or game:GetService("Players").LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game.RemoteListener:FindFirstChild("_Cutscenes")
				CutScenes.Name = enabled and "_Cutscenes" or "Cutscenes"
			end
		end
	})

	
local Workspace = game:GetService("Workspace")

do
    local ladderESPHandles = {}   
    local ancestryConns = {}      
    local descendantConn = nil

    local function addLadder(inst)
        if ladderESPHandles[inst] then return end
        -- Only consider if it's under CurrentRooms
        if not inst:IsDescendantOf(Workspace:WaitForChild("CurrentRooms")) then return end
        -- Ensure instance is of correct type; original code checks only Name
        if inst.Name == "Ladder" then
            -- Create ESP
            local handle = ESPLibrary:AddESP({
                Object = inst,
                Text = "Ladder",
                Color = Color3.fromRGB(0, 0, 255),
            })
            ladderESPHandles[inst] = handle
            -- Listen for removal to clean up ESP
            local conn = inst.AncestryChanged:Connect(function(_, parent)
                if not parent or not inst:IsDescendantOf(Workspace.CurrentRooms) then
                    -- Remove ESP and disconnect
                    if ladderESPHandles[inst] then
                        ESPLibrary:RemoveESP(ladderESPHandles[inst])
                        ladderESPHandles[inst] = nil
                    end
                    if ancestryConns[inst] then
                        ancestryConns[inst]:Disconnect()
                        ancestryConns[inst] = nil
                    end
                end
            end)
            ancestryConns[inst] = conn
        end
    end

    local function removeAllLadders()
        -- Disconnect ancestry listeners and remove ESP
        for inst, conn in pairs(ancestryConns) do
            conn:Disconnect()
        end
        ancestryConns = {}
        for inst, handle in pairs(ladderESPHandles) do
            ESPLibrary:RemoveESP(handle)
        end
        ladderESPHandles = {}
    end

    ESPBox:AddToggle("Ladder ESP", {
        Text = "Ladder ESP",
        Default = false,
        Callback = function(enabled)
            -- Cleanup existing listeners/ESP
            if descendantConn then
                descendantConn:Disconnect()
                descendantConn = nil
            end
            removeAllLadders()

            if not enabled then
                return
            end

            local roomsFolder = Workspace:FindFirstChild("CurrentRooms")
            if not roomsFolder then return end

            -- Initial scan using GetDescendants()
            for _, inst in ipairs(roomsFolder:GetDescendants()) do  -- 
                if inst.Name == "Ladder" then
                    addLadder(inst)
                end
            end

            -- Listen for future spawns
            descendantConn = roomsFolder.DescendantAdded:Connect(function(inst)  -- 
                if inst.Name == "Ladder" then
                    addLadder(inst)
                end
            end)
        end,
    })
end
-- Anticheat Bypass (Ladder Method)

if ReplicatedStorage.GameData.Floor.Value == "Mines" then
	local ladderBypassConnection = nil
	local ladderBypassCharConn = nil
	local roomAddedConn = nil
	local roomRemovedConn = nil

	local ladderHaltRoomExists = false
	local ladderBypassPaused = false
	local ladderBypassNotifiedPause = false
	local ladderBypassNotifiedResume = false

	local function IsHaltHallwayRoom(room)
		return room:GetAttribute("RawName") == "JKKKKKKKKSWU"
	end

	local function ScanExistingRooms()
		local parent = workspace:FindFirstChild("CurrentRooms")
		if not parent then return false end
		for _, child in ipairs(parent:GetChildren()) do
			if IsHaltHallwayRoom(child) then return true end
		end
		return false
	end

	local function OnRoomAdded(room)
		if IsHaltHallwayRoom(room) then
			ladderHaltRoomExists = true
			if ladderBypassConnection and not ladderBypassPaused then
				ladderBypassPaused = true
				ladderBypassNotifiedPause = false
				ladderBypassNotifiedResume = false
			end
		end
	end

	local function OnRoomRemoved(room)
		if IsHaltHallwayRoom(room) then
			ladderHaltRoomExists = false
			if ladderBypassPaused then
				ladderBypassPaused = false
				ladderBypassNotifiedPause = false
				ladderBypassNotifiedResume = false
			end
		end
	end

	local function BypassHeartbeat()
		if ladderHaltRoomExists then
			if not ladderBypassNotifiedPause then
				Library:Notify("[Anticheat Bypass] Next room is HaltHallway: bypass breaks.", 3)
				ladderBypassNotifiedPause = true
				ladderBypassNotifiedResume = false
			end
			return
		end
		if not ladderBypassNotifiedResume then
			ladderBypassNotifiedResume = true
			ladderBypassNotifiedPause = false
		end
		local char = Players.LocalPlayer.Character
		if char then
			char:SetAttribute("Climbing", false)
		end
	end

	local function StartLadderBypass()
		if ladderBypassConnection then return end
		ladderHaltRoomExists = ScanExistingRooms()

		local rooms = workspace:FindFirstChild("CurrentRooms")
		if rooms then
			roomAddedConn = rooms.ChildAdded:Connect(OnRoomAdded)
			roomRemovedConn = rooms.ChildRemoved:Connect(OnRoomRemoved)
		end

		ladderBypassConnection = RunService.Heartbeat:Connect(BypassHeartbeat)
		ladderBypassCharConn = Players.LocalPlayer.CharacterAdded:Connect(function(char)
			task.defer(function()
				char:SetAttribute("Climbing", false)
			end)
		end)
	end

	local function StopLadderBypass()
		if ladderBypassConnection then ladderBypassConnection:Disconnect() ladderBypassConnection = nil end
		if ladderBypassCharConn then ladderBypassCharConn:Disconnect() ladderBypassCharConn = nil end
		if roomAddedConn then roomAddedConn:Disconnect() roomAddedConn = nil end
		if roomRemovedConn then roomRemovedConn:Disconnect() roomRemovedConn = nil end
		ladderBypassPaused = false
		ladderHaltRoomExists = false
		ladderBypassNotifiedPause = false
		ladderBypassNotifiedResume = false
	end

	FloorsBx:AddToggle("AnticheatBypass", {
		Text = "Anticheat Bypass",
		Default = false,
		Callback = function(enabled)
			if enabled then
				StartLadderBypass()
			else
				StopLadderBypass()
			end
		end
	})
end
if ReplicatedStorage.GameData.Floor.Value == "Mines" then
	local TARGET_NAME = "SeekGuidingLight"
	local seekLightGuides = {}
	local ancestryConns = {}
	local descendantConn = nil
	local updateConnection = nil

	local function createGuideFor(target)
		if seekLightGuides[target] or not target:IsA("BasePart") then return end

		local guide = Instance.new("Part")
		guide.Name = "SeekLightGuide"
		guide.Size = Vector3.new(1, 1, 1)
		guide.Anchored = true
		guide.CanCollide = false
		guide.Material = Enum.Material.Neon
		guide.BrickColor = BrickColor.new("Bright yellow")
		guide.Transparency = 0.5
		guide.CFrame = target.CFrame
		guide.Parent = workspace

		seekLightGuides[target] = guide

		local conn = target.AncestryChanged:Connect(function(_, parent)
			if not parent or not target:IsDescendantOf(workspace) then
				if seekLightGuides[target] then seekLightGuides[target]:Destroy() seekLightGuides[target] = nil end
				if ancestryConns[target] then ancestryConns[target]:Disconnect() ancestryConns[target] = nil end
			end
		end)
		ancestryConns[target] = conn

		if not updateConnection then
			updateConnection = RunService.RenderStepped:Connect(function()
				local any = false
				for tgt, guide in pairs(seekLightGuides) do
					if tgt:IsDescendantOf(workspace) then
						guide.CFrame = tgt.CFrame
						any = true
					else
						guide:Destroy()
						seekLightGuides[tgt] = nil
						if ancestryConns[tgt] then
							ancestryConns[tgt]:Disconnect()
							ancestryConns[tgt] = nil
						end
					end
				end
				if not any then
					updateConnection:Disconnect()
					updateConnection = nil
				end
			end)
		end
	end

	local function removeAllGuides()
		for tgt, conn in pairs(ancestryConns) do conn:Disconnect() end
		ancestryConns = {}
		for _, guide in pairs(seekLightGuides) do guide:Destroy() end
		seekLightGuides = {}
		if updateConnection then updateConnection:Disconnect() updateConnection = nil end
	end

	FloorsBx:AddToggle("ShowSeekGuides", {
		Text = "Show PathfindingNodes (Seek)",
		Default = false,
		Callback = function(enabled)
			if descendantConn then descendantConn:Disconnect() descendantConn = nil end
			removeAllGuides()
			if not enabled then return end

			for _, inst in ipairs(workspace:GetDescendants()) do
				if inst:IsA("BasePart") and inst.Name == TARGET_NAME then
					createGuideFor(inst)
				end
			end

			descendantConn = workspace.DescendantAdded:Connect(function(inst)
				if inst:IsA("BasePart") and inst.Name == TARGET_NAME then
					createGuideFor(inst)
				end
			end)
		end
	})
end
	-- BEFORE using PlayerBox:AddToggle, define the Fly logic globally (or

	-- Services
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")

	local player = Players.LocalPlayer

	-- Fly table (global so PlayerBox callbacks and console can access it)
	Fly = Fly or {}
	Fly.Enabled = false
	Fly.Speed = 15
	Fly.FlyBody = nil
	Fly.FlyGyro = nil

	-- Connections (to be created/destroyed when flying toggles)
	local renderConn 
	local charAddedConn = nil

	-- Setup BodyVelocity & BodyGyro on HumanoidRootPart
	function Fly.SetupBodies(char)
		local root = char:FindFirstChild("HumanoidRootPart")
		if not root then return end

		-- BodyVelocity: maintain target velocity
		local bv = Instance.new("BodyVelocity")
		bv.Name = "FlyBodyVelocity"
		bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)   -- high force to override gravity/forces î¨پ6î¨‚
		bv.Velocity = Vector3.zero
		bv.Parent = root
		Fly.FlyBody = bv

		-- BodyGyro: maintain orientation matching camera
		local bg = Instance.new("BodyGyro")
		bg.Name = "FlyBodyGyro"
		bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)   -- high torque î¨پ7î¨‚
		local cam = workspace.CurrentCamera
		if cam then
			bg.CFrame = cam.CFrame
		end
		bg.Parent = root
		Fly.FlyGyro = bg

		-- Disable default physics on the humanoid
		local humanoid = char:FindFirstChild("Humanoid")
		if humanoid then
			humanoid.PlatformStand = true
		end
	end

	-- Cleanup bodies on disable
	function Fly.CleanupBodies()
		if Fly.FlyBody then
			Fly.FlyBody:Destroy()
			Fly.FlyBody = nil
		end
		if Fly.FlyGyro then
			Fly.FlyGyro:Destroy()
			Fly.FlyGyro = nil
		end

		-- Restore default physics
		local char = player.Character
		if char then
			local humanoid = char:FindFirstChild("Humanoid")
			if humanoid then
				humanoid.PlatformStand = false
			end
		end
	end

	-- Per-frame update while flying: apply camera-tilt-based movement
	local function onRenderStepped()
		if not Fly.Enabled then return end

		local char = player.Character
		if not char then return end

		local humanoid = char:FindFirstChild("Humanoid")
		local root = char:FindFirstChild("HumanoidRootPart")
		local cam = workspace.CurrentCamera
		if not humanoid or not root or not Fly.FlyBody or not Fly.FlyGyro or not cam then
			return
		end

		local dir = Vector3.zero

		if UserInputService.KeyboardEnabled then
			-- Desktop: WASD keys
			local forward = UserInputService:IsKeyDown(Enum.KeyCode.W)
			local back    = UserInputService:IsKeyDown(Enum.KeyCode.S)
			local left    = UserInputService:IsKeyDown(Enum.KeyCode.A)
			local right   = UserInputService:IsKeyDown(Enum.KeyCode.D)

			local camCFrame = cam.CFrame
			local lookVec = camCFrame.LookVector
			local rightVec = camCFrame.RightVector

			if forward then
				dir = dir + lookVec
			end
			if back then
				dir = dir - lookVec
			end
			if left then
				dir = dir - rightVec
			end
			if right then
				dir = dir + rightVec
			end
		else
			-- Mobile: use humanoid.MoveDirection for horizontal input (Y=0) î¨پ8î¨‚
			local moveDir = humanoid.MoveDirection
			if moveDir.Magnitude > 0 then
				local camCFrame = cam.CFrame
				local flatLook = Vector3.new(camCFrame.LookVector.X, 0, camCFrame.LookVector.Z)
				local flatRight = Vector3.new(camCFrame.RightVector.X, 0, camCFrame.RightVector.Z)
				if flatLook.Magnitude > 0 then
					flatLook = flatLook.Unit
				end
				if flatRight.Magnitude > 0 then
					flatRight = flatRight.Unit
				end

				local forwardWeight = moveDir:Dot(flatLook)
				local rightWeight = moveDir:Dot(flatRight)
				-- Combine full camera vectors (including Y) for vertical component
				dir = camCFrame.LookVector * forwardWeight + camCFrame.RightVector * rightWeight
			end
		end

		-- Apply velocity: if input present, move along dir at Fly.Speed; else hover
		if dir.Magnitude > 0 then
			Fly.FlyBody.Velocity = dir.Unit * Fly.Speed
		else
			Fly.FlyBody.Velocity = Vector3.zero
		end

		-- Match orientation to camera for consistent movement direction
		Fly.FlyGyro.CFrame = cam.CFrame

		-- Keep humanoid in PlatformStand
		humanoid.PlatformStand = true
	end

	-- Enable flying
	function Fly.Enable()
		if Fly.Enabled then return end
		Fly.Enabled = true

		-- Setup bodies if character exists
		local char = player.Character
		if char then
			Fly.SetupBodies(char)
		end

		-- Connect RenderStepped if not already
		if not renderConn then
			renderConn = RunService.RenderStepped:Connect(onRenderStepped)
		end

		-- Connect CharacterAdded to reapply on respawn
		if not charAddedConn then
			charAddedConn = player.CharacterAdded:Connect(function(char2)
				if Fly.Enabled then
					char2:WaitForChild("HumanoidRootPart")
					Fly.SetupBodies(char2)
				end
			end)
		end
	end

	-- Disable flying
	function Fly.Disable()
		if not Fly.Enabled then return end
		Fly.Enabled = false

		-- Cleanup bodies
		Fly.CleanupBodies()

		-- Disconnect RenderStepped
		if renderConn then
			renderConn:Disconnect()
			renderConn = nil
		end

		-- Disconnect CharacterAdded
		if charAddedConn then
			charAddedConn:Disconnect()
			charAddedConn = nil
		end
	end

	-- Toggle flying
	function Fly.Toggle()
		if Fly.Enabled then
			Fly.Disable()
		else
			Fly.Enable()
		end
	end

	-- Adjust speed
	function Fly.SetSpeed(newSpeed)
		Fly.Speed = newSpeed or Fly.Speed
	end

	-- PlayerBox slider integration for Fly.Speed
	FlySpeed = PlayerBox:AddSlider("FlySpeed", {
		Text = "Fly Speed",
		Min = 10,
		Max = 100,
		Default = Fly.Speed,
		Rounding = 0,
		Callback = function(v)
			Fly.SetSpeed(v)
		end
	})

	-- PlayerBox toggle integration
	PlayerBox:AddToggle("Fly", {
		Text = "Fly",
		Default = false,
		Callback = function(enabled)
			if enabled then
				Fly.Enable()
			else
				Fly.Disable()
			end
		end
	}):AddKeyPicker('Fly Keybind', {


		Default = 'F', -- String as the name of the keybind (MB1, MB2 for mouse buttons)
		SyncToggleState = true,


		-- You can define custom Modes but I have never had a use for it.
		Mode = 'Toggle', -- Modes: Always, Toggle, Hold

		Text = 'Fly', -- Text to display in the keybind menu
		NoUI = false, -- Set to true if you want to hide from the Keybind menu,

		-- Occurs when the keybind is clicked, Value is `true`/`false`
		Callback = function(Value)



		end,

		-- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
		ChangedCallback = function(New)
		end
	})
PlayerBox:AddDivider()
	-- Third-Person Camera with Head Hide/Show Integration in one script

	-- Services
	 Players = game:GetService("Players")
	 RunService = game:GetService("RunService")
	 Workspace = game:GetService("Workspace")

	 player = Players.LocalPlayer

	-- Offsets (initialized)
	 offsetX = 0
	 offsetY = 2   -- e.g., slightly above head center
	 offsetZ = 8   -- behind the head

	-- Connections and state
	 transparencyConnections = {}
	 renderConn = nil
	 charAddedConn = nil
	 toggleState = false

	-- Utility: lock LocalTransparencyModifier on head & accessories to a given value (0 = visible, 1 = fully invisible locally)
	 function lockTransparency(char, value)
		-- First disconnect any existing locks
		for _, conn in ipairs(transparencyConnections) do
			conn:Disconnect()
		end
		transparencyConnections = {}

		-- Iterate over children
		for _, v in ipairs(char:GetChildren()) do
			if v:IsA("Accessory") and v:FindFirstChild("Handle") then
				 handle = v.Handle
				-- Set immediately
				handle.LocalTransparencyModifier = value  -- î¨پ0î¨‚
				-- Lock it
				transparencyConnections[#transparencyConnections+1] = handle:GetPropertyChangedSignal("LocalTransparencyModifier"):Connect(function()
					handle.LocalTransparencyModifier = value
				end)
			end
			if v.Name == "Head" and v:IsA("BasePart") then
				 head = v
				head.LocalTransparencyModifier = value  -- î¨پ1î¨‚
				transparencyConnections[#transparencyConnections+1] = head:GetPropertyChangedSignal("LocalTransparencyModifier"):Connect(function()
					head.LocalTransparencyModifier = value
				end)
			end
		end
	end

	-- Camera update: set CFrame relative to head plus offsets
	 function updateCameraThirdPerson()
		 char = player.Character
		if not char then return end
		 head = char:FindFirstChild("Head")
		if not head then return end

		 cam = Workspace.CurrentCamera
		if not cam then return end

		-- Override CameraType to Scriptable so default camera logic doesn't override
		cam.CameraType = Enum.CameraType.Scriptable

		-- Compute new CFrame: head.CFrame * offset
		 baseCFrame = head.CFrame
		 offsetCFrame = CFrame.new(offsetX, offsetY, offsetZ)
		cam.CFrame = baseCFrame * offsetCFrame  -- î¨پ2î¨‚
	end

	-- Enable third-person: show head, lock transparency=0, connect camera update & respawn handling
	 function enableThirdPerson()
		if toggleState then return end
		toggleState = true

		 char = player.Character
		if char then
			-- Show head & accessories
			lockTransparency(char, 0)
		end

		-- Connect RenderStepped
		if not renderConn then
			renderConn = RunService.RenderStepped:Connect(updateCameraThirdPerson)  -- î¨پ3î¨‚
		end

		-- Respawn handling: re-lock transparency=0 and continue camera update after respawn
		if not charAddedConn then
			charAddedConn = player.CharacterAdded:Connect(function(newChar)
				-- Wait for head
				 head = newChar:WaitForChild("Head", 5)
				if head then
					lockTransparency(newChar, 0)
				end
			end)
		end
	end

	-- Disable third-person: hide head, lock transparency=1, disconnect camera update & restore default camera
	 function disableThirdPerson()
		if not toggleState then return end
		toggleState = false

		-- Disconnect RenderStepped
		if renderConn then
			renderConn:Disconnect()
			renderConn = nil
		end
		-- Disconnect respawn handler
		if charAddedConn then
			charAddedConn:Disconnect()
			charAddedConn = nil
		end

		-- Hide head & accessories
		 char = player.Character
		if char then
			lockTransparency(char, 1)
		end

		-- Restore default camera behavior
		 cam = Workspace.CurrentCamera
		if cam then
			cam.CameraType = Enum.CameraType.Custom  -- î¨پ4î¨‚
			-- Reset CameraSubject to Humanoid so first-person/follow works normally
			if player.Character then
				 humanoid = player.Character:FindFirstChild("Humanoid")
				if humanoid then
					cam.CameraSubject = humanoid  -- î¨پ5î¨‚
				end
			end
		end
	end

	-- Slider integration
	PlayerBox:AddSlider("ThirdPersonX", {
		Text = "Third Person X",
		Min = -10,
		Max = 10,
		Default = offsetX,
		Rounding = 0,
		Callback = function(v)
			offsetX = v
			if toggleState then
				updateCameraThirdPerson()
			end
		end
	})

	PlayerBox:AddSlider("ThirdPersonY", {
		Text = "Third Person Y",
		Min = -10,
		Max = 10,
		Default = offsetY,
		Rounding = 0,
		Callback = function(v)
			offsetY = v
			if toggleState then
				updateCameraThirdPerson()
			end
		end
	})

	PlayerBox:AddSlider("ThirdPersonZ", {
		Text = "Third Person Z",
		Min = -10,
		Max = 10,
		Default = offsetZ,
		Rounding = 0,
		Callback = function(v)
			offsetZ = v
			if toggleState then
				updateCameraThirdPerson()
			end
		end
	})

	-- Toggle integration
	PlayerBox:AddToggle("ThirdPerson", {
		Text = "Third Person",
		Default = false,
		Callback = function(enabled)
			if enabled then
				enableThirdPerson()
			else
				disableThirdPerson()
			end
		end
	}):AddKeyPicker('ThirdP Keybind', {


		Default = 'T', -- String as the name of the keybind (MB1, MB2 for mouse buttons)
		SyncToggleState = true,


		-- You can define custom Modes but I have never had a use for it.
		Mode = 'Toggle', -- Modes: Always, Toggle, Hold

		Text = 'ThirdPerson', -- Text to display in the keybind menu
		NoUI = false, -- Set to true if you want to hide from the Keybind menu,

		-- Occurs when the keybind is clicked, Value is `true`/`false`
		Callback = function(Value)



		end,

		-- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
		ChangedCallback = function(New)
		end
	})

	-- On initial load: ensure head is hidden so it won't block FOV in first-person by default
	-- e.g., if player spawns before toggling, hide head LocalTransparencyModifier
	-- (optional: comment out if you prefer head visible until toggled)
	if player.Character then
		lockTransparency(player.Character, 1)
	end
	-- Also handle respawn to keep head hidden by default
	player.CharacterAdded:Connect(function(newChar)
		newChar:WaitForChild("Head", 5)
		if not toggleState then
			lockTransparency(newChar, 1)
		else
			lockTransparency(newChar, 0)
		end
	end)
MiscBox3:AddDivider()
	
local Storage = Instance.new("Folder",Workspace)
Storage.Name = "AntiLagStorage"
	MiscBox3:AddToggle("AntiLag", {
		Text    = "Anti Lag",
		Default = false,
		Callback = function(on)
			if on then
for _, v in pairs(game.MaterialService:GetChildren()) do
v.Parent = workspace:WaitForChild("AntiLagStorage")
end
else
for _, part in ipairs(workspace:FindFirstChild("AntiLagStorage"):GetChildren()) do
part.Parent = game.MaterialService
end
end
end
})

	RunService = game:GetService("RunService")
Players = game:GetService("Players")
ReplicatedDS = game:GetService("ReplicatedStorage").GameData
CurrentRooms = workspace:WaitForChild("CurrentRooms")

Player = Players.LocalPlayer
Character = Player.Character or Player.CharacterAdded:Wait()

doorReachConn = nil
throttleTimer = 0
THROTTLE_INTERVAL = 0.15

-- Door Reach Toggle
DoorReach = MiscBox2:AddToggle("DoorReach", {
	Text = "Door Reach",
	Tooltip = "Makes Door Open From Far"
})

DoorReach:OnChanged(function(enabled)
	if doorReachConn then
		doorReachConn:Disconnect()
		doorReachConn = nil
		throttleTimer = 0
	end

	if not enabled then
		return
	end

	doorReachConn = RunService.Heartbeat:Connect(function(dt)
		throttleTimer = throttleTimer + dt
		if throttleTimer < THROTTLE_INTERVAL then return end
		throttleTimer =  throttleTimer -THROTTLE_INTERVAL

		room = CurrentRooms:FindFirstChild(ReplicatedDS.LatestRoom.Value)
		if not room then return end
if workspace:FindFirstChild("SeekMovingNewClone") or workspace:FindFirstChild("SeekMoving") then return end
		door = room:FindFirstChild("Door")
		if door and door:FindFirstChild("ClientOpen") then
			door.ClientOpen:FireServer()
		end
	end)
end)

-- Transparency Control
transparencyvalue = 0.5
closetstate = false
closetcon = nil

targets = {
	["Wardrobe"] = true, ["Locker_Large"] = true, ["Rooms_Locker"] = true, ["Backdoor_Wardrobe"] = true,
	["Bed"] = true, ["Toolshed"] = true, ["CircularVent"] = true, ["Rooms_Locker_Fridge"] = true,
	["RetroWardrobe"] = true, ["Dumpster"] = true, ["Double_Bed"] = true
}

function closettransparency(apply)
	for _, v in ipairs(CurrentRooms:GetDescendants()) do
		if targets[v.Name] and v:FindFirstChild("HidePrompt") and v:FindFirstChild("HiddenPlayer").Value == LocalPlayer.Character  then
			for _, b in ipairs(v:GetDescendants()) do
				if b:IsA("BasePart") and b.Name ~= "PlayerCollision" then
					b.Transparency = apply and transparencyvalue or 0
				end
			end
		end
	end
end

function closetupdate()
	if not closetstate then return end
	character = Player.Character
	if character and character:GetAttribute("Hiding") == true then
		closettransparency(true)
	else
		closettransparency(false)
	end
end

function closettoggle(enable)
	if closetcon then closetcon:Disconnect() closetcon = nil end
	closetstate = enable
	character = Player.Character or Player.CharacterAdded:Wait()
	if enable then
		if character:GetAttribute("Hiding") == true then
			closettransparency(true)
		end
		closetcon = character:GetAttributeChangedSignal("Hiding"):Connect(closetupdate)
	else
		closettransparency(false)
	end
end

ESPSettings:AddSlider("Transparency", {
	Text = "Transparency",
	Min = 0.5,
	Max = 1,
	Default = transparencyvalue,
	Rounding = 2,
	Callback = function(v)
		transparencyvalue = v
		if closetstate and Player.Character and Player.Character:GetAttribute("Hiding") == true then
			closettransparency(true)
		end
	end
})

ESPSettings:AddToggle("Transparency Closet", {
	Text = "Transparency Closet",
	Default = false,
	Callback = function(v)
		closettoggle(v)
	end
})
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local LocalPlayer = Players.LocalPlayer

local Closets = {}
local HideConn = nil
local ClosetUpdate = nil
local LastHideTime = 0

local function DebugLog(Text)
	print("[AutoCloset DEBUG]:", Text)
end

local function GetClosets()
	Closets = {}
	for _, Room in ipairs(workspace.CurrentRooms:GetChildren()) do
		local Assets = Room:FindFirstChild("Assets")
		if Assets then
			for _, V in pairs(Assets:GetChildren()) do
				if V.Name == "Wardrobe" or V.Name == "Rooms_Locker" or V.Name == "Rooms_Locker_Fridge"
					or V.Name == "Bed" or V.Name == "Double_Bed" or V.Name == "CircularVent" or V.Name == "Toolshed" then
					table.insert(Closets, V)
				end
			end
		end
	end
end

local function GetClosestCloset()
	local Root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	if not Root then return end

	local Nearest, MinDist
	for _, Closet in ipairs(Closets) do
		local ClosetPart = Closet:FindFirstChildWhichIsA("BasePart")
		if ClosetPart then
			local Dist = (ClosetPart.Position - Root.Position).Magnitude
			if not MinDist or Dist < MinDist then
				Nearest, MinDist = Closet, Dist
			end
		end
	end
	return Nearest, MinDist
end

local function GetEntity()
	local EntityList = {"A60", "A120", "RushMoving", "AmbushMoving", "GlitchRush", "GlitchAmbush","BackdoorRush"}
	for _, Name in ipairs(EntityList) do
		local E = workspace:FindFirstChild(Name)
		if E and E.PrimaryPart then
			DebugLog("Entity Found: " .. Name)
			return E
		end
	end
	DebugLog("No entity found.")
end

local function GetThreshold(Name)
	return Name == "A60" and 180
		or Name == "A120" and 90
		or Name == "RushMoving" and 150
		or Name == "AmbushMoving" and 230
		or Name == "GlitchRush" and 190
		or Name == "GlitchAmbush" and 200
		or 150
end

local function FirePrompt(Prompt)
	if Prompt and Prompt:IsA("ProximityPrompt") then
		DebugLog("Firing prompt.")
		 fireproximityprompt(Prompt)	end
end

AutoBox:AddToggle("AutoCloset", {
	Text = "Auto Closet",
	Default = false,
	Callback = function(On)
		if HideConn then HideConn:Disconnect() HideConn = nil end
		if ClosetUpdate then ClosetUpdate:Disconnect() ClosetUpdate = nil end

		if On then
			DebugLog("Auto Closet enabled.")
			GetClosets()

			ClosetUpdate = RunService.Heartbeat:Connect(function()
				GetClosets()
			end)

			HideConn = RunService.Heartbeat:Connect(function()
				local Entity = GetEntity()
				local Character = LocalPlayer.Character
				local Root = Character and Character:FindFirstChild("HumanoidRootPart")
				local Hiding = Character and Character:GetAttribute("Hiding")

				if not Entity or not Root then return end

				local Distance = (Entity.PrimaryPart.Position - Root.Position).Magnitude
				local Threshold = GetThreshold(Entity.Name)
				local EntityY = Entity.PrimaryPart.Position.Y

				DebugLog("Entity distance: " .. math.floor(Distance))
				DebugLog("Entity threshold: " .. Threshold)
				DebugLog("Entity Y: " .. EntityY)

				
				

				if Distance <= Threshold then
					DebugLog("Within hide range.")
					if not Hiding and tick() - LastHideTime > 0.4 then
						local Closet = GetClosestCloset()
						if Closet then
							local ClosetPart = Closet:FindFirstChildWhichIsA("BasePart")
							if ClosetPart and (ClosetPart.Position - Root.Position).Magnitude <= 13 then
								local Prompt = Closet:FindFirstChild("HidePrompt", true)
								if Prompt then
									DebugLog("Hiding...")
									FirePrompt(Prompt)
									
									LastHideTime = tick()
								else
									DebugLog("Prompt not found in closet.")
								end
							else
								DebugLog("Too far from closet.")
							end
						else
							DebugLog("No closest closet found.")
						end
					end
				elseif Distance > Threshold + 10 then
					if Hiding then
						DebugLog("Unhiding - entity gone.")
						Character:SetAttribute("Hiding", false)
					end
				end
			end)
		else
			DebugLog("Auto Closet disabled.")
		end
	end
})
if game.ReplicatedStorage.GameData.Floor.Value == "Rooms" then
	local PathfindingService = game:GetService("PathfindingService")
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local LocalPlayer = Players.LocalPlayer

	local PathID = 0
	local WaypointParts = {}
	local DestinationMarker

	local function ClearWaypoints()
		for _, part in pairs(WaypointParts) do
			if part and part.Parent then part:Destroy() end
		end
		WaypointParts = {}
	end

	local function ShowWaypoints(waypoints)
		ClearWaypoints()
		for _, wp in ipairs(waypoints) do
			local part = Instance.new("Part")
			part.Size = Vector3.new(0.4, 0.4, 0.4)
			part.Anchored = true
			part.CanCollide = false
			part.Material = Enum.Material.Neon
			part.Color = Color3.fromRGB(255, 255, 0)
			part.CFrame = CFrame.new(wp.Position)
			part.Parent = workspace
			table.insert(WaypointParts, part)
		end
	end

	local function ShowDestination(pos)
		if DestinationMarker then DestinationMarker:Destroy() end
		local part = Instance.new("Part")
		part.Size = Vector3.new(1, 0.3, 1)
		part.Anchored = true
		part.CanCollide = false
		part.Material = Enum.Material.Neon
		part.Color = Color3.fromRGB(0, 255, 0)
		part.Position = pos + Vector3.new(0, 0.3, 0)
		part.Shape = Enum.PartType.Cylinder
		part.Orientation = Vector3.new(90, 0, 0)
		part.Parent = workspace
		DestinationMarker = part
	end

	local function PathfindWalkTo(pos)
		PathID += 1
		local thisID = PathID
		local char = LocalPlayer.Character
		local hrp = char and char:FindFirstChild("HumanoidRootPart")
		local hum = char and char:FindFirstChildOfClass("Humanoid")
		if not hrp or not hum then return end

		local path = PathfindingService:CreatePath({
			WaypointSpacing = 4,
			AgentRadius = 0.2,
			AgentHeight = 2,
			AgentCanJump = true,
			AgentJumpHeight = 9,
			AgentCanClimb = false
		})

		path:ComputeAsync(hrp.Position, pos)
		if path.Status ~= Enum.PathStatus.Success then return end

		local waypoints = path:GetWaypoints()
		ShowWaypoints(waypoints)
		ShowDestination(pos)

		task.spawn(function()
			for i = 2, #waypoints do
				if PathID ~= thisID then break end
				hum:MoveTo(waypoints[i].Position)
				hum.MoveToFinished:Wait()
			end
		end)
	end

	local function GetClosestLocker()
		local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end
		local closest, dist
		for _, v in pairs(workspace.CurrentRooms:GetDescendants()) do
			if v:IsA("Model") and (v.Name == "Rooms_Locker" or v.Name == "Rooms_Locker_Fridge") then
				local part = v:FindFirstChildWhichIsA("BasePart")
				if part then
					local d = (part.Position - hrp.Position).Magnitude
					if not dist or d < dist then
						closest = part
						dist = d
					end
				end
			end
		end
		return closest
	end

	local function FirePrompt(prompt)
		if prompt and prompt:IsA("ProximityPrompt") then
			fireproximityprompt(prompt)
		end
	end

	FloorsBx:AddToggle("AutoRooms", {
		Text = "Auto Rooms",
		Default = false,
		Callback = function(state)
			if state then
				task.spawn(function()
					while Toggles.AutoRooms.Value do
						local char = LocalPlayer.Character
						local hrp = char and char:FindFirstChild("HumanoidRootPart")
						if not hrp then task.wait() continue end

						local A60 = workspace:FindFirstChild("A60")
						local A120 = workspace:FindFirstChild("A120")
						local Entity = workspace:FindFirstChild("Entity")

						if A60 or A120 then
							local locker = GetClosestLocker()
							if locker then
								PathfindWalkTo(locker.Position)
								repeat task.wait() until (hrp.Position - locker.Position).Magnitude <= 2

								local prompt = locker.Parent and locker.Parent:FindFirstChild("HidePrompt")
								FirePrompt(prompt)
							end
						elseif not Entity then
							if char:GetAttribute("Hiding") == true then
								char:SetAttribute("Hiding", false)
							end

							local roomNum = game.ReplicatedStorage.GameData.LatestRoom.Value
							local room = workspace.CurrentRooms:FindFirstChild(tostring(roomNum))
							local door = room and room:FindFirstChild("Door") and room.Door:FindFirstChild("Door")
							if door then
								PathfindWalkTo(door.Position)
								repeat task.wait() until (hrp.Position - door.Position).Magnitude <= 5
							end
						end

						task.wait(0.2)
					end
				end)
			else
				PathID += 1
				ClearWaypoints()
				if DestinationMarker then DestinationMarker:Destroy() end
			end
		end
	})
end
 

entity_names = {
	"RushMoving",
	"AmbushMoving",
	"A60",
	"A120",
	"GlitchRush",
	"GlitchAmbush"
}

spectatecon = nil
spectatevalue = false
camera = workspace.CurrentCamera
runservice = game:GetService("RunService")
players = game:GetService("Players")
localplayer = players.LocalPlayer

function getentity()
	for _, name in ipairs(entity_names) do
		ent = workspace:FindFirstChild(name)
		if ent and ent.PrimaryPart then
			return ent
		end
	end
end

function updatecamera()
	ent = getentity()
	if ent and localplayer.Character and localplayer.Character:GetAttribute("Hiding") then
		camera.CameraType = Enum.CameraType.Scriptable
		camera.CFrame = CFrame.lookAt(camera.CFrame.Position, ent.PrimaryPart.Position)
	end
end

AutoBox:AddToggle("Spectate", {
	Text = "Spectate Entity (While Hiding)",
	Default = false,
	Callback = function(state)
		spectatevalue = state
		if spectatecon then
			spectatecon:Disconnect()
			spectatecon = nil
		end
		if not spectatevalue then return end
		spectatecon = runservice.RenderStepped:Connect(updatecamera)
	end
})

Library:Notify("Loaded, Prohax, Successfully",3) 

workspace.DescendantAdded:Connect(function(inst)
	local name = inst.Name
	local parent = inst.Parent

	if inst:IsA("ProximityPrompt") then
		if isvalidprompt(inst) then
			if Toggles.AutoInteract.Value then
				validprompts[#validprompts + 1] = inst
			end
			if Toggles.InteractInstant.Value then
				inst.HoldDuration = 0
			end
		end
	end
	

	if Toggles.Items.Value then
		if itemSet[name] and inst:IsDescendantOf(currentRoom()) then
			addItem(inst)
		end
	end

	if Toggles.Gold.Value then
		if name == "GoldPile" and inst:IsDescendantOf(workspace.CurrentRooms) then
			addGoldPileESP(inst)
		end
	end

	if name == "Snare" and parent and parent.Name == "Assets" then
		local h = inst:WaitForChild("Hitbox",9e9)
		if h then
			h.CanTouch = not Toggles.AntiSnare.Value
		end
	end

	if name == "DoorFake" then
		task.wait()
		for _, p in ipairs(inst:GetChildren()) do
			if p:IsA("BasePart") then
				p.CanTouch = not Toggles.AntiDupe.Value
			end
		end
	end

	if name == "GiggleCeiling" then
		local h = inst:WaitForChild("Hitbox", 9e9)
		if h then
			h.CanTouch = not Toggles.AntiGiggle.Value
		end
	end

	if name == "Seek_Arm" then
		task.wait()
		for _, p in ipairs(inst:GetChildren()) do
			if p:IsA("BasePart") then
				p.CanTouch = not Toggles.AntiSeek.Value
			end
		end
	end

	if name == "ChandelierObstruction" then
		task.wait()
		for _, p in ipairs(inst:GetChildren()) do
			if p:IsA("BasePart") then
				p.CanTouch = not Toggles.AntiSeek.Value
			end
		end
	end

	if name == "BananaPeel" then
		inst.CanTouch = not Toggles.AntiBanana.Value
	end

	if name == "JeffTheKiller" then
		task.wait()
		for _, p in ipairs(inst:GetChildren()) do
			if p:IsA("BasePart") then
				p.CanTouch = not Toggles.AntiJeff.Value
			end
		end
	end

	if name == "Lava" then
		inst.CanTouch = not Toggles.AntiLava.Value
	end

	if name == "ScaryWall" then
		task.wait()
		for _, p in ipairs(inst:GetChildren()) do
			if p:IsA("BasePart") then
				p.CanTouch = not Toggles.AntiScaryWall.Value
			end
		end
	end

	if name == "SideroomSpace" then
		task.wait()
		for _, p in ipairs(inst:GetChildren()) do
			if p:IsA("BasePart") then
				p.CanTouch = not Toggles.AntiVacuum.Value
			end
		end
	end

	if name == "GloomEgg" then
		task.wait()
		for _, p in ipairs(inst:GetChildren()) do
			if p:IsA("BasePart") then
				p.CanTouch = not Toggles.AntiGloomPile.Value
			end
		end
	end

if Toggles.InfiniteItems.Value then
	if inst:IsA("ProximityPrompt") then
		handleprompt(inst)
	end
end

if Toggles.EntityESP.Value then
if EntityNames[inst.Name] then
				createesp(inst)
			end
end
if Toggles.EntityNotify.Value then
		if inst:IsA("Model") then
					 data = notifyentities[inst.Name]
					if data and not tracked_notify[inst] then
						tracked_notify[inst] = true
						Library:Notify(("› %s has spawned! %s"):format(data[1], data[2]), 4)
						Sound()
					end
				end
end
if Toggles.ChatNotify.Value then
if inst:IsA("Model") then
					 data = notifyentities[inst.Name]
					if data and not tracked_chat[inst] then
						tracked_chat[inst] = true
						ChatNotify(("› %s has spawned! %s"):format(data[1], data[2]))
						Sound()
					end
				end
end
if Toggles.DisableDrawersInteractionsSounds.Value then
    if (inst.Name == "Open" or inst.Name == "Close") and inst.Parent.Name == "Main" then
        inst:Destroy()
    end
end
end) 
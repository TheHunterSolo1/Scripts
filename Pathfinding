local Pathfinding = {}

local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local WaypointFolder = Workspace:FindFirstChild("PathfindingWaypoints") or Instance.new("Folder", Workspace)
WaypointFolder.Name = "PathfindingWaypoints"
WaypointFolder:ClearAllChildren()

Config = {
	Mode = "Walk",
	AgentRadius = 2,
	AgentHeight = 1,
	CanJump = true,
	CanClimb = true,
	WaypointColor = Color3.new(1, 0, 0)
}

local CurrentSessionID = 0
local CurrentWaypoints = {}

local function CreateVisual(Position)
	local Part = Instance.new("Part")
	Part.Name = "Waypoint"
	Part.Shape = Enum.PartType.Ball
	Part.Material = Enum.Material.Neon
	Part.Size = Vector3.new(1.5, 1.5, 1.5)
	Part.Position = Position
	Part.Color = Config.WaypointColor
	Part.Anchored = true
	Part.CanCollide = false
	Part.CanTouch = false
	Part.CanQuery = false
	Part.CastShadow = false
	Part.Parent = WaypointFolder
	table.insert(CurrentWaypoints, Part)
end

function Pathfinding:ClearWaypoints()
	for _, Part in ipairs(CurrentWaypoints) do
		Part:Destroy()
	end
	table.clear(CurrentWaypoints)
end

function Pathfinding:GetPathStatus()
	return "Active"
end

function Pathfinding:ForceStop()
	CurrentSessionID = CurrentSessionID + 1
	Pathfinding:ClearWaypoints()
	local LocalPlayer = Players.LocalPlayer
	if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
		LocalPlayer.Character.Humanoid:MoveTo(LocalPlayer.Character.HumanoidRootPart.Position)
	end
end

function Pathfinding:WalkTo(Target)
	CurrentSessionID = CurrentSessionID + 1
	local MySessionID = CurrentSessionID

	local LocalPlayer = Players.LocalPlayer
	if not LocalPlayer or not LocalPlayer.Character then return end
	
	local RootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	local Humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
	if not RootPart or not Humanoid then return end

	local TargetPosition
	if typeof(Target) == "Vector3" then
		TargetPosition = Target
	elseif typeof(Target) == "Instance" then
		if Target:IsA("BasePart") then
			TargetPosition = Target.Position
		elseif Target:IsA("Model") then
			TargetPosition = Target:GetPivot().Position
		end
	end

	if not TargetPosition then return end

	local Path = PathfindingService:CreatePath({
		AgentRadius = Config.AgentRadius,
		AgentHeight = Config.AgentHeight,
		AgentCanJump = Config.CanJump,
		AgentCanClimb = Config.CanClimb,
		WaypointSpacing = 3
	})

	local Success, ErrorMessage = pcall(function()
		Path:ComputeAsync(RootPart.Position, TargetPosition)
	end)

	if not Success or Path.Status ~= Enum.PathStatus.Success then return end

	if MySessionID ~= CurrentSessionID then return end

	Pathfinding:ClearWaypoints()
	
	local Waypoints = Path:GetWaypoints()

	if Config.Mode == "Show" or Config.Mode == "Both" then
		for _, Point in ipairs(Waypoints) do
			CreateVisual(Point.Position)
		end
	end

	if Config.Mode == "Show" then return end

	task.spawn(function()
		for i, Point in ipairs(Waypoints) do
			if MySessionID ~= CurrentSessionID then return end

			local WaypointPosition = Point.Position
			
			if Point.Action == Enum.PathWaypointAction.Jump and Config.CanJump then
				Humanoid.Jump = true
			end

			Humanoid:MoveTo(WaypointPosition)

			local Reached = false
			local MoveConnection
			
			MoveConnection = Humanoid.MoveToFinished:Connect(function()
				Reached = true
			end)

			while not Reached do
				if MySessionID ~= CurrentSessionID then 
					if MoveConnection then MoveConnection:Disconnect() end
					return 
				end
				
				if (RootPart.Position - WaypointPosition).Magnitude < 3 then
					Reached = true
				end
				
				task.wait()
			end
			
			if MoveConnection then MoveConnection:Disconnect() end
		end
		
		if MySessionID == CurrentSessionID then
			Pathfinding:ClearWaypoints()
		end
	end)
end

return Pathfinding

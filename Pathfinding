local Pathfinding = {}

local PathfindingService = game:GetService("PathfindingService")
local WaypointFolder = Instance.new("Folder",game:GetService("Workspace"))
local Debris = game:GetService("Debris")
getgenv().Mode = getgenv().Mode or "Walk" 





getgenv().AgentRadius = getgenv().AgentRadius or 2

getgenv().AgentHeight = getgenv().AgentHeight or 1


getgenv().CanJump = getgenv().CanJump or true

getgenv().CanClimb = getgenv().CanClimb or true


function Pathfinding:GenerateRandomString(Time)

local Chars = "abcdefghijklnmgxyzADCERGHDYYIJRDCCSXFOPPGRD123456789"

local Word = ""

for i = 1, Time do
local Letter = math.random(1, #Chars)

Word = Word .. Chars:sub(Letter,Letter)
end

return Word
end

WaypointFolder.Name = Pathfinding:GenerateRandomString(9)

local LocalPlayer = game:GetService("Players").LocalPlayer




function Pathfinding:CreateWaypoint(CF)
local Part = Instance.new("Part", WaypointFolder) Part.CanCollide = false
 Part.CanTouch = false 
Part.CanQuery = false
Part.Rotation = Vector3.new(0, 0, 90)
Part.Shape = "Ball" 
Part.Position = CF 
Part.Color = Color3.new(1, 0, 0)
Part.Size = Vector3.new(1.5, 1, 1.5) 
Part.Anchored = true


end
function Pathfinding:RemoveWaypoints()
WaypointFolder:ClearAllChildren()
end
local ShouldStop = false

function Pathfinding:ForceStop()
ShouldStop = true
repeat task.wait(0.1)

WaypointFolder:ClearAllChildren()
until  #WaypointFolder:GetChildren() < 1
task.spawn(function()
LocalPlayer.Character.Humanoid:MoveTo(LocalPlayer.Character.HumanoidRootPart.Position)
end)
task.wait(1)
ShouldStop = false
end

local OldMode
local BreakPath = false






function Pathfinding:WalkTo(Part)


if OldMode == nil then
OldMode = getgenv().Mode
end




 
if LocalPlayer.Character then
local GetRealPosition = Part:IsA("BasePart") and Part.Position or Part:IsA("Model") and Part:GetPivot().Position or nil
if GetRealPosition == nil then
print("bro get a real part or real model and stop trolling")
return
end

local dis = (LocalPlayer.Character.HumanoidRootPart.Position - GetRealPosition).Magnitude
if dis < 2 then return end
 local path = PathfindingService:CreatePath({
AgentRadius = getgenv().AgentRadius,
AgentHeight = getgenv().AgentHeight,
WaypointSpacing = 3,
AgentCanJump = getgenv().CanJump,
AgentCanClimb = getgenv().CanClimb
})



path:ComputeAsync(LocalPlayer.Character.HumanoidRootPart.Position,GetRealPosition)




if path.Status == Enum.PathStatus.Success then  
if not BreakPath then
BreakPath = true

RunService.Heartbeat:Wait()
BreakPath = false 

end
end
Pathfinding:RemoveWaypoints()


local waypoints = path:GetWaypoints()

for _, waypoint in pairs(waypoints) do
if ShouldStop then
Pathfinding:RemoveWaypoints()
 break end
if BreakPath then break end
if getgenv().Mode == "Show" or getgenv().Mode == "Both" then
Pathfinding:CreateWaypoint(waypoint.Position)
end
if getgenv().Mode == "Walk" then
Pathfinding:RemoveWaypoints()
end

end
for i, waypoint in pairs(waypoints) do
if BreakPath then break end

if OldMode ~= getgenv().Mode then
OldMode = getgenv().Mode
break
end
if ShouldStop then
Pathfinding:RemoveWaypoints()
 break end


local CloseCheck = (LocalPlayer.Character.HumanoidRootPart.Position - waypoint.Position).Magnitude
if  CloseCheck > 7 then
if waypoint.Action == Enum.PathWaypointAction.Jump then 
LocalPlayer.Character.Humanoid.Jump  = true end
if getgenv().Mode == "Walk" or getgenv().Mode == "Both" then
LocalPlayer.Character.Humanoid:MoveTo(waypoint.Position)



LocalPlayer.Character.Humanoid.MoveToFinished:Wait()

end
end

end

end

end
task.delay(0.3,function()
end)
end
return Pathfinding

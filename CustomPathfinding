local Pathfinding = {}
Pathfinding.__index = Pathfinding

local Services = {
	Players = game:GetService("Players"),
	RunService = game:GetService("RunService"),
	Workspace = game:GetService("Workspace")
}

local Settings = {
	AgentSize = Vector3.new(3, 5, 3),
	JumpHeight = 7,
	MaxSlope = 45,
	NodeSpacing = 4,
	MaxIterations = 4000,
	StuckTime = 0.5,
	ReachDist = 1.5
}

local Heap = {}
function Heap.new() return {Items = {}, Count = 0} end
function Heap.push(heap, item)
	heap.Count += 1
	heap.Items[heap.Count] = item
	local i = heap.Count
	while i > 1 do
		local p = math.floor(i/2)
		if heap.Items[i].F < heap.Items[p].F then
			heap.Items[i], heap.Items[p] = heap.Items[p], heap.Items[i]
			i = p
		else break end
	end
end
function Heap.pop(heap)
	local first = heap.Items[1]
	heap.Items[1] = heap.Items[heap.Count]
	heap.Items[heap.Count] = nil
	heap.Count -= 1
	local i = 1
	while true do
		local c1, c2 = i*2, i*2+1
		local swap = c1
		if c1 > heap.Count then break end
		if c2 <= heap.Count and heap.Items[c2].F < heap.Items[c1].F then swap = c2 end
		if heap.Items[swap].F < heap.Items[i].F then
			heap.Items[i], heap.Items[swap] = heap.Items[swap], heap.Items[i]
			i = swap
		else break end
	end
	return first
end

local function GetGround(pos)
	local params = RaycastParams.new()
	params.FilterDescendantsInstances = {Services.Players.LocalPlayer.Character, Services.Workspace:FindFirstChild("PF_Vis")}
	params.FilterType = Enum.RaycastFilterType.Exclude
	local res = Services.Workspace:Blockcast(CFrame.new(pos + Vector3.new(0, Settings.JumpHeight, 0)), Settings.AgentSize, Vector3.new(0, -20, 0), params)
	return res
end

local function CheckPassable(startPos, endPos)
	local dir = endPos - startPos
	if dir.Magnitude < 0.1 then return true end
	local params = RaycastParams.new()
	params.FilterDescendantsInstances = {Services.Players.LocalPlayer.Character, Services.Workspace:FindFirstChild("PF_Vis")}
	params.FilterType = Enum.RaycastFilterType.Exclude
	local res = Services.Workspace:Blockcast(CFrame.new(startPos + Vector3.new(0, 2, 0)), Settings.AgentSize * 0.9, dir, params)
	return res == nil
end

local function Reconstruct(node)
	local path = {}
	while node do
		table.insert(path, 1, node)
		node = node.Parent
	end
	local smooth = {path[1]}
	local idx = 1
	while idx < #path do
		local nextIdx = idx + 1
		for i = #path, idx + 2, -1 do
			if CheckPassable(path[idx].Position, path[i].Position) then
				nextIdx = i
				break
			end
		end
		table.insert(smooth, path[nextIdx])
		idx = nextIdx
	end
	return smooth
end

function Pathfinding:MoveTo(target)
	local char = Services.Players.LocalPlayer.Character
	if not char then return end
	local root = char:FindFirstChild("HumanoidRootPart")
	local hum = char:FindFirstChild("Humanoid")
	if not root or not hum then return end
	
	if Services.Workspace:FindFirstChild("PF_Vis") then Services.Workspace.PF_Vis:Destroy() end
	
	local startHit = GetGround(root.Position)
	local endHit = GetGround(target)
	if not startHit or not endHit then return end
	
	local open = Heap.new()
	local closed = {}
	local startNode = {Position = startHit.Position, G = 0, H = (startHit.Position - endHit.Position).Magnitude, Parent = nil}
	startNode.F = startNode.G + startNode.H
	Heap.push(open, startNode)
	
	local best = startNode
	local iter = 0
	
	while open.Count > 0 do
		iter += 1
		if iter > Settings.MaxIterations then break end
		local curr = Heap.pop(open)
		
		local k = math.floor(curr.Position.X)..":"..math.floor(curr.Position.Z)
		if closed[k] then continue end
		closed[k] = true
		
		if (curr.Position - endHit.Position).Magnitude < Settings.NodeSpacing then
			best = curr
			break
		end
		
		if curr.H < best.H then best = curr end
		
		for x = -1, 1 do
			for z = -1, 1 do
				if x == 0 and z == 0 then continue end
				local off = Vector3.new(x, 0, z).Unit * Settings.NodeSpacing
				local nextPos = curr.Position + off
				local ground = GetGround(nextPos)
				
				if ground then
					local dy = ground.Position.Y - curr.Position.Y
					if dy <= Settings.JumpHeight and math.acos(ground.Normal.Y) < math.rad(Settings.MaxSlope) then
						if CheckPassable(curr.Position, ground.Position) then
							local g = curr.G + (curr.Position - ground.Position).Magnitude
							local h = (ground.Position - endHit.Position).Magnitude
							local node = {Position = ground.Position, G = g, H = h, F = g+h, Parent = curr, Jump = dy > 1.2}
							Heap.push(open, node)
						end
					end
				end
			end
		end
	end
	
	local path = Reconstruct(best)
	
	local folder = Instance.new("Folder")
	folder.Name = "PF_Vis"
	folder.Parent = Services.Workspace
	for i, n in ipairs(path) do
		local p = Instance.new("Part")
		p.Size, p.Anchored, p.CanCollide, p.Material, p.Color = Vector3.new(0.5,0.5,0.5), true, false, Enum.Material.Neon, Color3.new(1,0,0)
		p.Position = n.Position
		p.Parent = folder
	end
	
	task.spawn(function()
		local currentIdx = 1
		local lastPos = root.Position
		local stuckTimer = 0
		
		while currentIdx <= #path do
			local goal = path[currentIdx]
			local dist = (root.Position * Vector3.new(1,0,1) - goal.Position * Vector3.new(1,0,1)).Magnitude
			
			if dist < Settings.ReachDist then
				currentIdx += 1
			else
				hum:MoveTo(goal.Position)
				if goal.Jump or (goal.Position.Y > root.Position.Y + 2) then hum.Jump = true end
				
				if (root.Position - lastPos).Magnitude < 0.1 then
					stuckTimer += Services.RunService.Heartbeat:Wait()
					if stuckTimer > Settings.StuckTime then
						hum.Jump = true
						stuckTimer = 0
						local nudge = root.CFrame.RightVector * (math.random() > 0.5 and 2 or -2)
						hum:MoveTo(root.Position + nudge)
						task.wait(0.2)
					end
				else
					stuckTimer = 0
				end
				lastPos = root.Position
			end
			Services.RunService.Heartbeat:Wait()
		end
		folder:Destroy()
	end)
end

return Pathfinding

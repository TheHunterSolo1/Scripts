local Library = {}
getgenv().ESPLibrary = Library

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

local ESPList = {}
local LoopConnection = nil
local Settings = {
	Tracers = false,
	Distance = false,
	Arrows = false,
	BaseSize = 15
}

local Vector2_new = Vector2.new
local Vector3_new = Vector3.new
local Math_floor = math.floor
local Math_atan2 = math.atan2
local Math_cos = math.cos
local Math_sin = math.sin
local Math_min = math.min
local Math_deg = math.deg

local DrawingLib = {
	Line = Drawing.new("Line"),
	Triangle = Drawing.new("Triangle")
}
DrawingLib.Line:Remove()
DrawingLib.Triangle:Remove()

local function GetRoot(obj)
	if obj:IsA("BasePart") then
		return obj
	elseif obj:IsA("Model") then
		return obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart")
	end
	return nil
end

local function ClearObject(part)
	if ESPList[part] then
		local data = ESPList[part]
		
		if data.Highlight then data.Highlight:Destroy() end
		if data.Gui then data.Gui:Destroy() end
		if data.Indicator then data.Indicator:Destroy() end
		
		if data.Tracer then
			data.Tracer.Visible = false
			data.Tracer:Remove()
		end

		if data.Signal then
			data.Signal:Disconnect()
		end
		
		ESPList[part] = nil
	end
end

function Library:GenerateRandomString()
	local length = math.random(10, 20)
	local charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	local result = ""
	
	for i = 1, length do
		local rand = math.random(1, #charset)
		result = result .. string.sub(charset, rand, rand)
	end
	
	return result
end

function Library:SetTracers(state)
	Settings.Tracers = state
end

function Library:ShowDistance(state)
	Settings.Distance = state
end

function Library:SetArrows(state)
	Settings.Arrows = state
	
	if not state then
		for _, data in pairs(ESPList) do
			if data.Indicator then
				data.Indicator.Visible = false
			end
		end
	end
end

function Library:SetBaseSize(size)
	Settings.BaseSize = size
end

function Library:RemoveESP(part)
	ClearObject(part)
end

function Library:AddESP(part, name, color)
	if not part or ESPList[part] then return end
	
	local root = GetRoot(part)
	if not root then return end
	
	local highlight = Instance.new("Highlight")
	highlight.Name = "ESPHighlight"
	highlight.FillColor = color
	highlight.OutlineColor = color
	highlight.FillTransparency = 0.7
	highlight.OutlineTransparency = 0.5
	highlight.Adornee = part
	highlight.Enabled = true
	highlight.Parent = part
	
	local billboard = Instance.new("BillboardGui")
	billboard.Name = "ESPInfo"
	billboard.Adornee = root
	billboard.Size = UDim2.new(0, 200, 0, 60) 
	billboard.StudsOffset = Vector3_new(0, 3.5, 0)
	billboard.AlwaysOnTop = true
	billboard.Enabled = true
	billboard.Parent = part
	
	local label = Instance.new("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UDim2.new(1, 0, 1, 0)
	label.TextStrokeTransparency = 0
	label.TextColor3 = color
	label.Font = Enum.Font.GothamBold
	label.TextSize = Settings.BaseSize
	label.Text = name
	label.Parent = billboard
	
	local indicator = Instance.new("ImageLabel")
	indicator.Name = "OffscreenIndicator"
	indicator.Size = UDim2.new(0, 32, 0, 32)
	indicator.BackgroundTransparency = 1
	indicator.Image = "rbxassetid://80246768534622"
	indicator.ImageColor3 = color
	indicator.ZIndex = 10
	indicator.Visible = false
	indicator.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
	
	local line = nil

	local success, _ = pcall(function()
		line = Drawing.new("Line")
		line.Visible = false
		line.Color = color
		line.Thickness = 1
		line.Transparency = 1
	end)
	
	local cleanupSignal = part.AncestryChanged:Connect(function(_, parent)
		if not parent then
			Library:RemoveESP(part)
		end
	end)
	
	ESPList[part] = {
		Root = root,
		Highlight = highlight,
		Gui = billboard,
		Label = label,
		Tracer = line,
		Indicator = indicator,
		Color = color,
		Signal = cleanupSignal,
		Name = name
	}
end

function Library:Unload()
	if LoopConnection then 
		LoopConnection:Disconnect() 
	end
	
	for part, _ in pairs(ESPList) do
		ClearObject(part)
	end
	
	getgenv().ESPLibrary = nil
end

LoopConnection = RunService.RenderStepped:Connect(function()
	local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	if not myRoot then return end
	
	local myPos = myRoot.Position
	local viewSize = Camera.ViewportSize
	
	local currentFOV = Camera.FieldOfView
	local dynamicSize = Math_floor(Settings.BaseSize * (currentFOV / 70))
	if dynamicSize < 12 then dynamicSize = 12 end
	if dynamicSize > 40 then dynamicSize = 40 end
	
	local camCFrame = Camera.CFrame

	for part, data in pairs(ESPList) do
		if data.Root and data.Root.Parent then
			local targetPos = data.Root.Position
			local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
			local dist = (myPos - targetPos).Magnitude
			
			if onScreen then
				if not data.Highlight.Enabled then data.Highlight.Enabled = true end
				if not data.Gui.Enabled then data.Gui.Enabled = true end

				if data.Label.TextSize ~= dynamicSize then
					data.Label.TextSize = dynamicSize
				end
				
				if Settings.Distance then
					data.Label.Text = string.format("%s\n[%d]", data.Name, Math_floor(dist))
				else
					data.Label.Text = data.Name
				end
				
				if data.Indicator and data.Indicator.Visible then
					data.Indicator.Visible = false
				end

				if data.Tracer then
					if Settings.Tracers then
						data.Tracer.From = Vector2_new(viewSize.X / 2, viewSize.Y)
						data.Tracer.To = Vector2_new(screenPos.X, screenPos.Y)
						data.Tracer.Color = data.Color
						data.Tracer.Visible = true
					else
						data.Tracer.Visible = false
					end
				end
			else
				if data.Highlight.Enabled then data.Highlight.Enabled = false end
				if data.Gui.Enabled then data.Gui.Enabled = false end
				if data.Tracer then data.Tracer.Visible = false end

				if data.Indicator and Settings.Arrows then
					local rel = camCFrame:PointToObjectSpace(targetPos)
					local ang = Math_atan2(-rel.Y, rel.X)
					local deg = Math_deg(ang)
					
					local radius_scale = 0.40 
					
					local x_scale = 0.5 + Math_cos(ang) * radius_scale
					local y_scale = 0.5 + Math_sin(ang) * radius_scale
					
					data.Indicator.Position = UDim2.new(
						x_scale, 
						-data.Indicator.Size.X.Offset / 2, 
						y_scale, 
						-data.Indicator.Size.Y.Offset / 2
					)
					
					data.Indicator.Rotation = deg
					data.Indicator.Visible = true
				elseif data.Indicator then
					data.Indicator.Visible = false
				end
			end
		else
			ClearObject(part)
		end
	end
end)

return Library
